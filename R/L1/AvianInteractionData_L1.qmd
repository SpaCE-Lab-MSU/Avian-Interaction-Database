---
title: "L1 taxonomic harmonization"
author: 
  - Phoebe L. Zarnetske
  - Patrick Bills
format:
  html:
    toc: true
    toc-depth: 3
    embed-resources: true
editor: source
date: 09/01/2025
date-format: iso
---

## Avian Interaction Pairs Data: L0 to L1 taxonomic harmonization

### About

- **PROJECT:** Avian Interaction Database
- **COLLABORATORS:** Vincent Miele, Stephane Dray, Emily Parker
- **Run Date:** `r Sys.Date()`

### Data input:

**Avian Interaction Database L0**

Raw Data, combined (stitched) and with content
cleaning but taxonomic names as entered (older names, typos, etc)

*Set the interactions database file to read from here:*

( output From `R/L0/AvianInteractionData_L0_stitch.R` )

```{r}

AvianInteractionData_L0_file <- "AvianInteractionData_L0_stitch.csv" 
```


Main Checklists:

- Full Clements/Ebird list 
- GBIF database (via taxadb package)

Curated Species checklist: 

- Current selected species list =
  combined checklist based on Clements/eBird v2024, Avibase v8.17, BBS v2024:
  output from `R/L0/AvianInteractionData_specieslists_L0.R`
  - used for species lookup / matching


### DATA OUTPUT:

Taxonomic Resolution Table: 

Avian Interaction Database, cleaned and with taxonomic names resolved to 
match checklists listed above: `AvianInteractionData_L1.csv`

```{r}
AvianInteractionData_L1_file <- "AvianInteractionData_L1.csv" 

today_date_string <- format(Sys.Date(),"%Y-%m-%d")
taxonomic_resolutions_file_name =  paste0("AvianInteractionData_L1_taxonomic_resolutions_", today_date_string, ".csv")

AvianInteractionData_L1_taxonomy_table_file <- "AvianInteractionData_L1_taxnomony_resolutions.csv"
```


### Next script to run: 

- AvianInteractionData_L1_post_taxa_cleaning.R
- AvianInteractionData_L1_CanadaCONUS.R


### NOTES

This script is used to refine species name changes to align with the 
Clements & eBird checklist to create an Rdata file.  

Currently, the script is working for a checklist of CONUS+Canada.  

L0 data are checked to assign updated scientific and common names to the interaction pairs data. Makes a new column that also includes scientific name changes associated with the AOUcombo.index for merging with those names in the AvianInteractionData_AOUindex_L1.csv


GOOD EXAMPLE TO TRACE MATCHING: Aeronautes saxitalis should be Aeronautes saxatalis

### Workflow Summary

At each step, resolution narrows down those names that require manual entry 
in a table to identify the current accepted name in checklist

1. setup 
   - read in checklists and L0 data
   - final data cleaning to ensure no typos etc
   -  create a name resolution table to be completed
2. fix missing scientific names manually 
3. match scientific names matching checklist
4. use fuzzy matching to find close scientific names to checklist
5. resolve names common names matching checklist
6. use fuzzy matching to find close common names
7. use gbif to see if name can be resolved to a checklist name
8. add manual fixes 
9. save data files


### Versions

-   Original R script `AvianInteractionData_L1.R` 27 Oct 2022 (PLZ)
-   updated through 12 Dec 2024 (PLZ);
    -   As of Dec. 12, 2024, this is mainly cleaned for BBS species
-  May 2025- July 2025 convert to workflow notebook/Quarto, (PSB)
-  August 2025, using new species lists Canada+CONUS from PLZ (PSB)
-  September 10, 2025, using species lists from commit from PLZ (PSB)
-  Oct 1, 2025: workflow reorginzation for better taxonomic resolution (PSB)


## TO DO / Notes

code/function to match to checklist to be able to be moved around

change and reorder the the section `## Join with Checklist and report`
 = since we are not relying on taxadb, dont' need a 'checklist' column but simply 
 an 'edit' column to indicate final dispensation and will use notes to indicate where it came from (checklist, gbif, etc)

perhaps also include the species code from Clements in the final taxonomy table 
so that it can be looked up next year directly to see if scientific name has changed

read the original 2024 list, not my version that has 2023/22 links (does not add rows)

add code to get the timestamp for the L0 file and report that here

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Data Set-up

File paths used for this run:

```{r}
#| echo: false

# functions used by all 
source(here::here('R/L0/L0_functions.R'))
# functions for this process to reduce this script size
# and load libraries used here
source(here::here('R/L1/L1_taxonomy_functions.R'))

file_paths <- get_file_paths()

print(file_paths)
```

*Note that the Checklist folder above is in L0 which contains species lists, 
but the subset list for 2024-25 analysis is in L1 as it's built from L0 lists*

### Setup: Checklists

#### Curated List

**Previously:** all species in BBS `"bbs_splist_2024_L1.csv"`

(the 2024 release which includes all species as of 2023, plus the additional 
AOUcombo.index column for use w BBS AOU index)

`splist2024<-read.csv(file.path(L1_dir,"bbs_splist_2024_L1.csv"))`

**Current**

September 2025: new curated list curated by PLZ using Clements, AVIBase, BBS etc. 
See `R/L1/AvianInteractionData_specieslists_Canada_CONUS_L1.R`

```{r}

current_species_list_filename <- "canada.conus.splist_L1.csv"
splist2024_filepath <- file.path(file_paths$L1,"species_checklists",current_species_list_filename )
splist2024 <- read.csv(splist2024_filepath)
print(paste("Read in ", nrow(splist2024), "entries from checklist file", splist2024_filepath))

```

#### Main Checklist

Read in the full check list the official eBird/Clements v2024 checklist

```{r}
#| label: read_clements


checklist_filename <- "eBird-Clements-v2024-integrated-checklist-October-2024-rev.csv"
checklist.orig <- read.csv(file.path(file_paths$CHECKLIST_FOLDER,checklist_filename))
print(paste("Read in ", nrow(checklist.orig), "entries from checklist file", checklist_filename))
```

amend column names of checklist to match for merging later show col name before and after change

```{r}
print(names(checklist.orig))
checklist <- checklist.orig
names(checklist)[names(checklist) == "scientific.name"] <-"scientific_name"
names(checklist)[names(checklist) == "English.name"] <-"common_name"
print("CORRECTED CHECKLIST COLUMNS:")
print(names(checklist))
```

We are using the GBIF list (via taxadb) to resolve scientific names and the 
eBird/Clements v2024 checklist (reflected in Birds of The World naming conventions for species). 
Some BBS names differ from these lists so they have to be resolved manually.

```{r}
#| echo: false

# cheap function using global var checklist to make it easy
on_checklist <- function(sciname){
  rows<- filter(checklist, scientific_name == sciname)
  if(nrow(rows)>0 ) return(TRUE)
  
  return(FALSE)
}
```
#### Interactions Data

To use a different or test files, edit this L0 filename:

```{r}
full_path_stitched_file <- file.path(file_paths$L0,AvianInteractionData_L0_file)
int.raw<-read.csv(full_path_stitched_file)
print(paste("read in ", nrow(int.raw), "records from ", full_path_stitched_file))
```

### Final Interaction Data Cleaning/Corrections

Most of these filters and adjustments are now made during the L0_stitch process
but were are ensuring the data is clean prior to matching taxonomy


#### Remove blank rows

```{r}
before_filter_nrow <- nrow(int.raw)
int.raw <- filter(int.raw,!(is.na(species1_scientific)& 
                             is.na(species2_scientific) & 
                             is.na(species1_common) & 
                             is.na(species2_common)
                           ))

print( paste(as.integer(before_filter_nrow - nrow(int.raw)), "blank rows removed"))
```

#### Trim white space from all names columns

```{r}
# trim white space

int.raw <- dplyr::mutate(int.raw, 
                         species1_scientific = trimws(species1_scientific,which=c("right")), 
                         species2_scientific = trimws(species2_scientific,which=c("right")), 
                         species1_common = trimws(species1_common,which=c("right")),
                         species2_common = trimws(species2_common,which=c("right"))
) 

print("unique scientific name combos after removing white space")
print(length(unique(paste(int.raw$species1_scientific, int.raw$species2_scientific))))
```

#### Missing Scientific name check

Are there any records that are missing a scientific name for species1?

*if so this is problematic for adjusting the recorded name with the checklist 
name, and should be corrected in data entry files*

```{r}
records.missingsp1 <- int.raw[is.na(int.raw$species1_scientific),]
tibble(records.missingsp1)
```

Records missing a scientific name for sp2

```{r}
records.missingsp2 <- int.raw[is.na(int.raw$species2_scientific),]
tibble(records.missingsp2)

```

Are there rows that have *only* common names for both sp1 and sp2?

```{r}
 
int.common_names_only <- dplyr::filter(int.raw, is.na(species1_scientific) & is.na(species2_scientific))
  
print(nrow(int.common_names_only))
```

#### remove rows that do not have interactions

*These should be corrected in the L0 correct process, 
but catch them here before correcting taxonomy*

List rows with both interaction columns missing

```{r}
#| echo: false
# to allow us to re-run this, look to see if we saved the var with all rows
# because we've run the cells below, and if so, reset our main df to that one
if(exists("int.raw.saved_all_rows")) int.raw<- int.raw.saved_all_rows

print("n rows with both effects missing:")
print(nrow(filter(int.raw, is.na(effect_sp1_on_sp2) & is.na(effect_sp2_on_sp1))))
print("n rows with at least one effect present:")
print(nrow(filter(int.raw, !is.na(effect_sp1_on_sp2) | !is.na(effect_sp2_on_sp1))))
print("list of rows with both effects missing:")
```

Table of rows with both effects missing:

```{r}
#| echo: false

tibble(filter(int.raw, is.na(effect_sp1_on_sp2) & is.na(effect_sp2_on_sp1)))
```

Remove those with no interactions (if any)
```{r}

# save the original full list in case we need to check again
int.raw.saved_all_rows <- int.raw

int.raw <- filter(int.raw, !is.na(effect_sp1_on_sp2) | !is.na(effect_sp2_on_sp1))
print("rows remaining with not both effects NA:")
print(nrow(int.raw))
```

#### Some quick typo fixes

This is the same function run during stitching, but run it again and to create
a cleaned L0 data set to work with 

```{r}

int.raw<-fix_taxon_typos(int.raw)

```


#### Discovery and repair of missing Sp1/Sp2 scientific names

List rows with missing sp1 values but have other data to use for fix

```{r}
records.missingsp1 <- int.raw[is.na(int.raw$species1_scientific),]
print(records.missingsp1)
```

Fix these missing species directly by matching the common_names from checklist

```{r}
#| echo: false
 
for(common_name_for_missingsp1  in records.missingsp1$species1_common){
  print(common_name_for_missingsp1)
  
  matching_sp<- checklist %>% 
    dplyr::filter(common_name == common_name_for_missingsp1) %>% 
    dplyr::select(common_name, scientific_name)  
  
  print(as.vector(matching_sp[1,]$scientific_name))
  # print(subset(checklist, common_name == common_name_for_missingsp1))
}
```


Assign scientific names to all rows for those common names 
that have missing sp1 scientific names, create a Manual Assignment structure 
here

```{r}
#| echo: false
manual_assignments = list()
manual_assignments[["Rhinoceros Auklet"]] <- "Cerorhinca monocerata"

print(manual_assignments)
# add more as needed  
```

apply the manual assignments

```{r}
for(cname in names(manual_assignments)){
  print(paste("set records with common name", cname, "to sp1 = ", manual_assignments[[cname]]))
  print("n rows to update:")
  print(nrow(int.raw[int.raw$species1_common == cname & is.na(int.raw$species1_scientific),]))
  int.raw[
    int.raw$species1_common == cname & 
    is.na(int.raw$species1_scientific),
    ]$species1_scientific = manual_assignments[[cname]] 
}

  
```

double check: remaining records with **missing sp1:**

```{r}
records.missingsp1 <- int.raw[is.na(int.raw$species1_scientific),]
print(records.missingsp1)  
```

### Discovery and repair of missing Sp2 scientific

rows with missing **sp2 scientific**:

```{r}
records.missingsp2<- int.raw[is.na(int.raw$species2_scientific),]
print( records.missingsp2)
```


Saved outcome from Previous run
```         
May 2025: 2 rows need editing 
species1_common species2_common         species1_scientific
866         White-cheeked Pintail   Cinnamon Teal Anas bahamensis rubirostris
14223 Middle American Screech-Owl            <NA>        Megascops guatamalae
species2_scientific effect_sp1_on_sp2 effect_sp2_on_sp1          interaction
866                  <NA>                 1                 1 facilitation-feeding
14223                <NA>                NA                NA                 <NA>
one had both NA interactions , now we are removing those
```



List the names from the checklist that match those missing in sp2:

```{r}
#| echo: false
#| 
for(common_name_for_missingsp2  in records.missingsp2$species2_common){
  print(checklist %>% 
    dplyr::filter(common_name == common_name_for_missingsp2) %>% 
    dplyr::select(common_name, scientific_name))
}
```

**Sp2 fix list**

update this list of fixes as errors are discovered above

Note that the common names will be update updated below with the checklist

```{r}
#| echo: false
manual_assignments = list()
manual_assignments["Cinnamon Teal"] <-  "Spatula cyanoptera"
# add more as needed  
print(manual_assignments)
```

fix sp2 using the list above

```{r}
# species2 fixes using the list above
for(cname in names(manual_assignments)){
  print(paste("set records with common name", cname, "to sp2 = ", manual_assignments[[cname]]))
  print("n rows to update with this command name and missing sp2:")
  rows_to_fix <- nrow(
    int.raw[int.raw$species2_common == cname & is.na(int.raw$species2_scientific),]
  )
  
  print(rows_to_fix)
  if(rows_to_fix > 0 ){
  int.raw[
    int.raw$species2_common == cname & 
    is.na(int.raw$species2_scientific),
    ]$species2_scientific = manual_assignments[[cname]] 
  }
}
  # double check remaining rows with missing sp2 (should be zero)
```

Double check that there are no remaining rows with missing scientific names

```{r}
tibble(int.raw[is.na(int.raw$species2_scientific),]) 
```
*completed fixes for missing scientific names*








--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Taxonomy Adjustments Table

**Create new data frame of all names, as is in the raw file, and what is to be 
adjusted/updated/assigned


Column Definitions:

- scientific_name.raw : L0 name as it appears in the original CSV file (stitched)
- common_name.raw : L0 name as it appears in the original CSV file (stitched)
- scientific_name_clements2024 : L1 name to be used (pre checklist )
- common_name_clements2024 : L1 name to be used (pre checklist )
- edit_notes: text of why edits were made

The edit columns are based on Clements 2024
Determine how many unique entries are in int.raw\$species1_scientific, which 
are unique combos of scientific names.

```{r}
unique.sp.raw <- data.frame(scientific_name.raw = with(int.raw, union(
  species1_scientific, species2_scientific
)))

print(dim(unique.sp.raw)) #3913 # May 29, 2025: 3889; Sept. 29, 2025: 3879
```


**Create Name Edits Table**

Create list of unique scientific_name.raw and common_name.raw pairs with 
formatting adjustments, stacking and collecting anything in sp1 and sp2. 
See documentation in `L1_taxonomy_functions.R` script for details

*note:  since adjustments/corrections to species were added to L0 cleaning 
process, there should be very few differences between 'raw' and 'edited' 
names at this point in the process*


```{r}
## create the raw <- edit adjustments table 
int.raw.names <- create_names_edit_table(int.raw)
head(tibble(int.raw.names))
```


Number of unique species in taxonomy edits table  - no resolutions made yet

```{r}
#| echo: false
#| output: true

nrow(unique(unresolved_species(int.raw.names)))

```

Historical numbers of unresolved species:
May 2025: 3889
Sept 2025: 3876


Test case to track with knwnn misspelling: Accipiter cooperi was misspelled ( should be Accipiter cooperii) - exists in int.raw.names

```{r}
known_misspellings <- c("Accipiter cooperi")
tibble(dplyr::filter(int.raw.names, scientific_name.raw %in% known_misspellings))
```

expected output:

```         
scientific_name.raw common_name.raw scientific_name.edit common_name.edit
1 Accipiter cooperi   Cooper's Hawk  Accipiter cooperi    Cooper's Hawk
```



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

### Example Checking process:


Discovery that Dendroica pinus - Pine Warbler - genus was updated to Setophaga pinus

checklists for the old and then new name FOR THIS SPECIES

```{r}
scientific_name.raw <- "Dendroica pinus"

```

is this is being used? records with old name: 
```{r}
#| echo: false
#| output: true
print(interaction_count_by_species(int.raw,scientific_name.raw  ))

```
records with new name:
```{r}
#| echo: false
#| output: true

print(interaction_count_by_species(int.raw, "Setophaga pinus"))
```

Which is preferred on the checklist?
```{r}
checklist[which(checklist$scientific_name == "Dendroica pinus"), ] # no records
checklist[which(checklist$scientific_name == "Setophaga pinus"), ] # one record
```

Is there an entry in our name edit table with the old genus?
```{r}
tibble(int.raw.names[int.raw.names$scientific_name.raw == "Dendroica pinus",])
```

add edited name and note

```{r}
int.raw.names <- add_name_edits(edits.df = int.raw.names,
               scientific_name.raw = "Dendroica pinus", 
               scientific_name.edit = "Setophaga pinus",
               edit_notes = "Update to new checklist name"
)
```











--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Checklist matches

Identify those species from the database that are already on the latest checklist
and add a note to track those. These do not need to be resolved. 


```{r}

# update in place

on_checklist_note <- "L0 species as entered on checklist (Clements 2024)"

species_categories = c("group (monotypic)","species","slash","subspecies" )
checklist.species<- filter(checklist, category %in% species_categories)$scientific_name

# make a copy
int.raw.names.checklist_match <- int.raw.names
# add note when it matches
int.raw.names.checklist_match[int.raw.names$scientific_name.edit %in% checklist.species, ]$edit_notes <- on_checklist_note

print(unresolved_species(int.raw.names.checklist_match))

```


#### L0 Checklist matching Summary

Number rows with species already on the checklist, so already resolved, which includes
full species and subspecies, but not slashes, unids, families or hybrids

```{r}
#| echo: false
#| output:true

nrow(filter(int.raw.names.checklist_match, !is.na(edit_notes) ))
```


Unique scientific names in the database NOT matched to the checklist : 
```{r}

nrow(unique ( unresolved_species(int.raw.names.checklist_match)))

```
September 2025: 545 rows 

### save to actual list and continue

```{r}
int.raw.names <- int.raw.names.checklist_match
```


Remaining (unique) scientific names to resolve: 

```{r}
#| echo: false
#| output: true

length(unique(unresolved_species(int.raw.names)$scientific_name.raw))

```
September 2025: 504 (just about 30 redundant common names)








--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Fuzzy Matching of Scientific Name to checklist

Use fuzzy logic function ( see L1_taxonomy_functions.R ) to find closest match from the CHECKLIST reference list
Function to find the closest match with a similarity score, try and determine what misspellings exist 


#### Reference list of scientific names from eBird Clements CHECKLIST 2024**

Create a reference list from our Checklist read in above (Clements)

```{r}

checklist.species<- filter(checklist, category == "species" | category == "slash" | category == "subspecies")

reference_names <- tibble(
  scientific_name = checklist.species$scientific_name,
  common_name = checklist.species$common_name
)
nrow(reference_names)

```
### repeat of names to resolve: 

```{r}

print(length(unique(unresolved_species(int.raw.names)$scientific_name.edit)))
```
### Resolve matches based on scientific_name.edit and Clements Checklist

Calculate the fuzzy match score and closest name in the checklist for 
each record in the unresolved names

*(this takes several minutes to complete)*

```{r}
# prepare a data frame to fill up with match data with current unresolved species
scientific_name_matches <- unresolved_species(int.raw.names)
# add new columns
# tracking original row number will make subsetting and cross-ref easier later
scientific_name_matches$row_number <- unresolved_species_rows(int.raw.names)
scientific_name_matches$closest_scientific_name_match <- NA
scientific_name_matches$scientific_name_match_score <- NA


# fill them in one row at a time
for(r in 1:nrow(scientific_name_matches)) {
  # optional, print the name we are on to gauge progress
  # print(scientific_name_matches[r,"scientific_name.edit"])
  fuzzy_match <- find_closest_match_with_score( scientific_name_matches[r,"scientific_name.edit"], checklist$scientific_name)
  scientific_name_matches[r,]$closest_scientific_name_match <- fuzzy_match$match
  scientific_name_matches[r,]$scientific_name_match_score <- fuzzy_match$score
}

# idea to improve speed: rewrite scientific_name_matches to accept a vector/list of names 
# and return list of lists, then rbind/cbind

tibble(scientific_name_matches)
```

Distribution of Match Scores

```{r}
library(ggplot2)
g<- ggplot(scientific_name_matches, aes(scientific_name_match_score)) +  
        geom_histogram(binwidth=0.01, color = "#000000", fill = "#0099F8") # + 

print(g)

```


Test of checklist and data : Accipiter cooperi is misspelled AND has been changed to Astur, 
so the match is not even the same  - should have a match of about 0.84

```{r}

incorrect_sp_to_check <-"Accipiter cooperi" 
print(dplyr::filter(scientific_name_matches, 
                    scientific_name.raw %in% c(incorrect_sp_to_check))$scientific_name_match_score)
```



#### Scientific Name Matching Set High Confidence threshold


After review of matches, all of the matches with score > 0.95 looked correct, 
and many but not all in range from 0.095 > score > 0.90 so those need to be checked. 

Setting the threshold to 0.95 for automatic assignment, and will add common name 
matching to increase confidence in the others

```{r}
high_confidence_threshold <- 0.95
```

Number of unique species with high confidence matches (scientific_name_match_score >= `{r} high_confidence_threshold` )

```{r}
#| echo: false
#| output: true
high_confidence_matches <-  filter(scientific_name_matches, 
                                   scientific_name_match_score >= high_confidence_threshold
                                   )
print(length(unique(high_confidence_matches$scientific_name.raw)))
proportion_high_confidence = length(unique(high_confidence_matches$scientific_name.raw)) / length(unique(scientific_name_matches$scientific_name.raw))
print(sprintf("%.2f%%", round(proportion_high_confidence*100,2)))
```
```{r}
View(high_confidence_matches )

```
*previous results:*

`Dec 2024: 257 out of 326; May 29, 2025: 244 out of 309`

Sept 2025:
  - >= 0.95 134 (33%)
  - >= 0.90 211
  
### Assign note to all high confidence matches. 

```{r}
edit_note <- "high confidence str match to checklist (Clements 2024) "
# make a copy
int.raw.names.matches <- int.raw.names
# fill the matching rows with the matched sci names
int.raw.names.matches[high_confidence_matches$row_number,]$scientific_name.edit<- high_confidence_matches$closest_scientific_name_match
int.raw.names.matches[high_confidence_matches$row_number,]$edit_notes <- paste( edit_note, round(high_confidence_matches$scientific_name_match_score,3))

View(int.raw.names.matches)
```

```{r}
#| echo: false
# after review, save these resolutions back to main list variable
int.raw.names <- int.raw.names.matches
rm(int.raw.names.matches)
```

### Medium Confidence species rows

Remaining species to resolve after high-confidence match

```{r}
#| echo: false
#| output: true

length(unique(unresolved_species(int.raw.names)$scientific_name.raw))
```





### Fuzzy match lower confidence matching


```{r}

medium_confidence_threshold <- 0.90
minimum_confidence_threshold <- 0.80

medium_confidence_matches <- filter(scientific_name_matches, 
                                     scientific_name_match_score < high_confidence_threshold & 
                                     scientific_name_match_score >= medium_confidence_threshold)

low_confidence_matches <- filter(scientific_name_matches, 
                                     scientific_name_match_score < medium_confidence_threshold & 
                                     scientific_name_match_score >= minimum_confidence_threshold)

```

### Determine lower confidence threshold

After review it appears that names may be matched correctly at a lower threshold
than some names matched incorrectly (at higher threshold), that is, it's a mix
from in matches from 0.90 - 0.95. 

Hold these and match on common name first, then re-run fuzzy matching

skipp this because the histogram shows this data 
```{r}
# score_start <- min(high_confidence_matches$scientific_name_match_score)
# score_end <- max(high_confidence_matches$scientific_name_match_score)
# increment <- 0.005
# 
# # collect these in a list for exploring
# confidence_partition <- list()
# 
# # Loop through each score range and print the matches within that range
# for (i in seq(score_start, score_end, by = increment)) {
#   current_range <- high_confidence_matches %>%
#     filter(scientific_name_match_score >= i & scientific_name_match_score <= i + increment)
#   
#   # Print the current range if it has any entries
#   if (nrow(current_range) > 0) {
#     low_range <- sprintf("%.2f", i)
#     high_range <- sprintf("%.2f", i + increment)
#     range_text = paste(low_range, "to", high_range)
#     print(paste("Match Score Range:",range_text ,": ", nrow(current_range), "records"))
#     confidence_partition[[high_range]]<- current_range
#     # print(current_range, n=100) # print up to 100 rows in a section
#   }
# }
# 
# ```
# View any of these dataframes using the partition list to see what's on there
# ```{r}
#  confidence_partition[["0.91"]]
```


---

## CHECKPOINT: save current workspace with current date

```{r}

today_date_string <- format(Sys.Date(),"%Y-%m-%d")
rdata_file_name <- paste0("AvianInteractionData_L1_workspace", today_date_string, ".RData")
save.image(file.path(file_paths$L1,rdata_file_name ))
```





--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Match on Common names

after applying high-confidence matches, try matching on common names using 
the same technique. 

Exact matches will have fuzzy match score=1.0, but just less coding to go through
the whole matching process instead of direct match and then fuzzy match

```{r}
on_checklist_note <- "L0 species matched by common name to checklist (Clements 2024)"

species_categories = c("group (monotypic)","species","slash","subspecies" )
checklist.common<- filter(checklist, category %in% species_categories)$common_name
```

Build the common name matching table

```{r}
# create list of names to match from unresolved rows
name_matches<- unresolved_species(int.raw.names)
# add new columns
name_matches$row_number <- unresolved_species_rows(int.raw.names)
name_matches$closest_name_match <- NA
name_matches$name_match_score <- NA
name_matches$scientific_name.checklist <- NA

# fill them in one row at a time
for(r in 1:nrow(name_matches)) {
  # optional, print the name we are on to gauge progress
  # print(scientific_name_matches[r,"scientific_name.edit"])
  
  raw_common_name<-name_matches[r,"common_name.raw"] 
  fuzzy_match <- find_closest_match_with_score(raw_common_name, checklist.common)
  
  # find the associated sci name, but only look at species records 
  # (some groups have the same common name for the whole genus)
  scientific_name_lookup <- as.character(filter(checklist, 
                                    common_name == fuzzy_match$match & category == "species") %>%   
                          select(scientific_name))
  if(length(scientific_name_lookup) == 0) warning(paste(" no scientific name in checklist for ",fuzzy_match$match))
  else {
    name_matches[r,]$closest_name_match <- fuzzy_match$match
    name_matches[r,]$name_match_score <- fuzzy_match$score
    name_matches[r,]$scientific_name.checklist <- scientific_name_lookup 
  }
}
```



```{r}
View(name_matches %>% arrange(desc(name_match_score)))
```

#### Example Matches to set threshold

Raw  Checklist Match ( match value)

- *Northern Jancan* matches *Northern Jacana* 0.9458333	=> correct
- *Black-Winged Babbler*	matches *Black-chinned Babbler*	0.9190476 => incorrect 

Conclusion setting threshold for match scores minimum 0.940 for high-confidence matches
which corrects a good number of species.  

```{r}
common_name_match_threshold <- 0.94
```

Update name edits using common name matches

```{r}
#| echo: false

high_confidence_common_matches <- filter(name_matches, name_match_score >= common_name_match_threshold)

# update by Row number. Not very R-like but works
# get the row numbers of names list already updated -> this process will not overwrite existing notes
# if following the notebook in order, these are mutually exclusive, but this ensures it could be 
# run out of order
rows_with_non_empty_notes <- which(!is.na(int.raw.names$edit_notes))

rows_to_update <- setdiff(high_confidence_common_matches$row_number, rows_with_non_empty_notes) # [!rows_high_confidence_match  %in% rows_with_non_empty_notes ]

print(paste("updating", length(rows_to_update), "rows"))

common_match_note <- "high confidence common name fuzzy match (Clements 2024) "

# make a copy (since matching takes a while)
int.raw.names.matches<- int.raw.names
# using saved row numbers, update scientific_name.edit and edit_note in bulk
int.raw.names.matches[high_confidence_common_matches$row_number,]$scientific_name.edit<- high_confidence_common_matches$scientific_name.checklist
# paste in the confidence level of these matches
int.raw.names.matches[high_confidence_common_matches$row_number,]$edit_notes <- paste( common_match_note, round(high_confidence_common_matches$name_match_score,3))


```

Remaining unresolved rows after high confidence scientific and common name matches

```{r}
#| echo: false
#| output: true
nrow(unresolved_species(int.raw.names.matches))
```
```{r}
#| echo: false
#| output: true

# after review, copy these resolve to the main names list
int.raw.names <- int.raw.names.matches
```





--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Optional, Save the unresolved 

Save our current unresolved species (prior to GBIF matching) in order to import
into a spreadsheet to build a fixes table the first time. 

This maybe useful for comparison in future years

First, add a custom column with some notes
```{r}
int.raw.names.unresolved <- unresolved_species(int.raw.names)
int.raw.names.unresolved$row_number <- unresolved_species_rows(int.raw.names)
int.raw.names.unresolved$comments <- ""

## add a comment with the match score for common name
# first create the comment to use linked by row number we saved during that process
common_name_match <- filter(name_matches, row_number %in% int.raw.names.unresolved$row_number) %>%
    mutate(comment = paste("common name match: ", closest_name_match, round(name_match_score,2), scientific_name.checklist, ";")) %>% select(row_number, comment)
# update the comment, linking on row number
int.raw.names.unresolved<- mutate(int.raw.names.unresolved, comments = paste(comments, common_name_match[common_name_match$row_number == row_number, "comment"]))

## add comment with the match score for scientific name
# first create the comment to use linked by row number we saved during that process
scientific_name_match <- filter(scientific_name_matches, row_number %in% int.raw.names.unresolved$row_number ) %>%
  mutate(comment = paste("scientific name match: ", closest_scientific_name_match, round(scientific_name_match_score,2),";")) %>% 
  select(row_number, comment)
  
# add this match score to the comments in our unresolved list
#int.raw.names.unresolved
int.raw.names.unresolved<- mutate(int.raw.names.unresolved, 
           comments = paste(comments, scientific_name_match[scientific_name_match$row_number == row_number, "comment"]))

```

Save CSV of our current unresolved species

```{r}
today_date_string <- format(Sys.Date(),"%Y-%m-%d")
temp_file_name <- paste0("unresolved_L1", today_date_string, ".csv")
write.csv(int.raw.names.unresolved, file=file.path(file_paths$L1,temp_file_name ), row.names = FALSE)
print(paste("saved ", file.path(file_paths$L1,temp_file_name )))
```













--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


## TaxaDB and GBIF Matching

taxadb package: Modified from this code:
https://docs.ropensci.org/taxadb/articles/intro.html 

In previous code, tried ITIS and COL to see if they were better than GBIF. 
GBIF has the fewest NA values, so we are sticking with it (it is the most comprehensive).

The GBIF database is frequently at odds with the Clements checklist.  Taxadb will
help find synonms for a scientific name, but the result is often not on the checklist. 

However, it may be good at finding a handful of synonyms that _are_ on the checklist. 

This process takes the remaining unresolved names, finds the accepted GBIF name for them, 
and if that name is also on Clements, that is what will be assigned


### Create a local GBIF database

Create a local gbif database in :
```{r}
taxadb::td_create("gbif")
```

Resolve scientific names for the scientific names, 
based on scientific_name.edit using GBIF

```{r}
int.gbif.names <- unresolved_species(int.raw.names) %>%
  mutate(
    scientific_id = taxadb::get_ids(scientific_name.edit, "gbif"),
    accepted_scientific_name = taxadb::get_names(scientific_id, "gbif")
  )
warnings()
```
**list join warnings**

For those entries that are ambiguous (\> 1 match of the edited species with gbif),
a warning will be issued. This loops through those warnings and prints 
the message that has the species in question so we can view and capture it.

```{r}

ws<- dplyr::last_dplyr_warnings()
print(paste("there are ", length(ws), "species have >1 identifier and need to be resolved w BOW"))

for( w in ws) print(w$parent)
```

IF there are duplicate matches (there will be warnings here)


###  TaxaDB/GBIF Edits review

of unresolved, how many had GBIF matches:

```{r}
#| echo: false
#| output: true

print(
  paste(
    nrow(filter(int.gbif.names, !is.na(scientific_id) )),
    "of",
    length(unresolved_species_rows(int.raw.names))
  )
)
```

How many of those gbif matches are on the checklist?

```{r}
#| echo: false
#| output: true

# checklist.species is defined above for other matching 
gbif_on_checklist <- filter(int.gbif.names, accepted_scientific_name %in% checklist.species$scientific_name )
print(nrow(gbif_on_checklist))
```

Note that one of these is domestic chicken and that needs to be edited by manually 
as GBIF matches to *Gallus gallus* but checklist that is the African wild species, 
and on the checklist Domestic Chicken is *Gallus gallus (Domestic type)*

see table of updates 



Number of un-id names (genera only, not expected to Taxadb to match, just accounting):

```{r}
int.raw.names.unid <- filter(int.raw.names, grepl(" sp\\.$", scientific_name.edit))
print(paste("rows:", nrow(int.raw.names.unid)))
print(paste("unique:", length(unique(int.raw.names.unid$scientific_name.edit))))

```





For those that matched in gbif AND not already have an note, add note including
the GBIF ID number that matched.  

```{r}
# this is maybe not the most R way to do this
# find the rows in our names that matched GBIF, and take out the rows that already 
# have a note in them, and update all of those notes
rows_that_have_gbif_match <- which(!is.na(int.gbif.names$scientific_id))##  match(resolved.gbif$scientific_name.raw, int.raw.names$scientific_name.raw)
rows_with_non_empty_notes <- which(!is.na(int.raw.names$edit_notes))

rows_to_update <- rows_that_have_gbif_match[! rows_that_have_gbif_match  %in% rows_with_non_empty_notes ]

for(r in rows_to_update){
   if ( int.raw.names[r,]$scientific_name.edit != int.gbif.names[r, "accepted_scientific_name"]){
     warning(paste(int.raw.names[r,"scientific_name.edit"], "did not match gbif name", int.raw.names[r,"accepted_scientific_name"]))
   }
   int.raw.names[r,]$edit_notes <- paste('matched GBIF to ', as.character(int.gbif.names[r,"scientific_id"]))
}
```



Remaining names to be fixed

```{r}
View(unresolved_species(int.raw.names))
```



#### Wrap-up manual fixes

Unique scientific names in unresolved list and manu: 

```{r}
length(unique(unresolved_species(int.raw.names)$scientific_name.raw))
```


Remaining Unresolved Species:

```{r}
nrow(unresolved_species(int.raw.names))
```


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Scientific Name Changes: Low Confidence Matches on scientific name

Extract scientific name matches with lower confidence (match_score <= 0.90) 
for those remaining species that didn't match for further 
checking

```{r}

low_confidence_matches <- scientific_name_matches %>%
  filter(
    (scientific_name_match_score < 0.9 & !is.na(scientific_name_match_score)) 
  ) %>% 
  filter( # remove unid species from matches
    !grepl(" sp\\.$", closest_scientific_name_match)
  ) %>% 
  filter(
    scientific_name.raw %in% unresolved_species(int.raw.names)$scientific_name.raw
  ) 

  # couldn't get Mutate to work, so here is a loop to add in the common name where it's found
  low_confidence_matches$common_name.checklist <- NA
  for(r in 1:nrow(low_confidence_matches)){
    common_names <- filter(checklist,scientific_name == low_confidence_matches[r,"closest_scientific_name_match"] & category == "species")$common_name
    if(length(common_names)==1) low_confidence_matches[r,"common_name.checklist"]<- common_names[1]
  }


length(unique(low_confidence_matches$scientific_name.raw))
```

previously 69 out of 326 - checks out OK; May 29, 2025: 65
Sept 2025: 9 




Scroll through these Low Confidence Matches in order from highest to lowest

Assigning closest low-confidence match with update notes,
and will be updated if necessary below



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
### Manual edits 

These are being transferred to a table to apply in bulk




```{r}

checklist[which(checklist$common_name == "Black-necked Stilt"), ]
```

```{r}
filter(int.raw.names, scientific_name.edit == "Himantopus mexicanus")
```

Pomarine Jaeger = Stercorarius pomarinus 

```{r}

interaction_count_by_species(int.raw,"Stercorarius stercorarius")
checklist[which(checklist$common_name == "Pomarine Jaeger"), ]

int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Stercorarius stercorarius",
                 scientific_name.edit = "Stercorarius pomarinus",
                 edit_notes = "KEEP RAW but edit: checklist: Pomarine Jaeger = Stercorarius pomarinus Also raw has space at end 5 Stercorarius stercorarius Stercorarius parasiticus    Pomarine Jaeger     Pomarine Jaeger  0.857
"

)

```



White Wagtail

```{r}

int.raw.names <- add_name_edits( int.raw.names, 
        scientific_name.raw = "Moticilla alba",
        scientific_name.edit = "Motacilla citreola",
        edit_notes = "Common name in int.raw is the White Wagtail. Moticilla alba            Motacilla citreola             0.858"
  )

```




--------------------------------------------------------------------------------

## Unid sp.  fixes


Open the Unid sp. (Genu-only) to work on:

How many unique Unid sp?
 
```{r}
int.raw.names.unid <- filter(int.raw.names, grepl(" sp\\.$", scientific_name.raw))
length(unique(int.raw.names.unid$scientific_name.edit))

# optional, in Rstudio, open the list in a new tab
# View(int.raw.names.unid )

```



--------------------------------------------------------------------------------


## SUMMARY Examine Name Corrections and Notes so far

*TO-DO: move this into a function so can be called at each step in workflow

Total number of name combinations in database:


```{r}
#| echo: false
#| output: true

print(nrow(int.raw.names))

```

number of full species without notes (dispensation/edits) :

```{r}
#| echo: false
#| output: true

print(nrow(unresolved_species(int.raw.names)))

```

number of all rows without notes (dispensation/edits) including UnID:

```{r}
#| echo: false
#| output: true

print( nrow( filter(int.raw.names, is.na(edit_notes))))

```


### checkpoint save
```{r}
#| echo: false
#| output: true

today_date_string <- format(Sys.Date(),"%Y-%m-%d")
rdata_file_name <- paste0("AvianInteractionData_L1_workspace", today_date_string, ".RData")
f <- file.path(file_paths$L1,rdata_file_name )
save.image(f)

print(paste("whole enviroment saved as ", f))

```





--------------------------------------------------------------------------------

## Checklist common-name fuzzy match (this was repeated when were doing GBIF< may not be needed/redundant)


1) get the accepted common name from Taxadb for matching Scientific name
2) match this common name with Clements 

## Fuzzy Match on Common names

after applying high-confidence matches, try matching on common names

```{r}

# list of rows that aren't matched yet

# create list of names to match from unresolved rows
name_matches<- unresolved_species(int.raw.names)
# add new columns
name_matches$closest_name_match <- NA
name_matches$name_match_score <- NA
name_matches$scientific_name.checklist <- NA

checklist_common_names<- filter(checklist,category == "species" )$common_name

# fill them in one row at a time
for(r in 1:nrow(name_matches)) {
  # optional, print the name we are on to gauge progress
  # print(scientific_name_matches[r,"scientific_name.edit"])
  
  raw_common_name<-name_matches[r,"common_name.raw"] 
  fuzzy_match <- find_closest_match_with_score(raw_common_name, checklist_common_names)
  

  
  # find the associated sci name, but only look at species records 
  # (some groups have the same common name for the whole genus)
  scientific_name_lookup <- as.character(filter(checklist, 
                                    common_name == fuzzy_match$match & category == "species") %>%   
                          select(scientific_name))
  if(length(scientific_name_lookup) == 0) warning(paste(" no scientific name in checklist for ",fuzzy_match$match))
  else {
    name_matches[r,]$closest_name_match <- fuzzy_match$match
    name_matches[r,]$name_match_score <- fuzzy_match$score
    name_matches[r,]$scientific_name.checklist <- scientific_name_lookup 
  }
}
```



```{r}
name_matches %>% arrange(desc(name_match_score))
```





--------------------------------------------------------------------------------


## Manual Fixes

**Workflow: **


Two ways to add an edit/adjustment to the list:

1. call the `add_name_edits` function with arguments including the data frame
   used to collect these edits (`int.raw.names`, see above)

2. add to this list below with the arguments in the following order, which are 
   added one by one calling that `add_name_edits` function
  
   - original scientific_name (raw) as appears in interaction file, 
   - editing notes, dispensation or why an edit is needed or d, 
   - (optional) scientific_name.edit IF the name is changed
   - (optional) common_name.edit if the name was changed 





Goal is to accumulate a list of fixes and notes

1. review existing edits below
   use a lookup function to see if an edit (raw -> edit, common name) is still needed
   TO-DO : write this lookup/diagnostic function or block of code here!!

2. use sleuthing to  


Our current workflow use `int.raw.names`  and resolves in this order: 

1. scientific_name.raw : what's in entered data
2. scientific_name.edit : corrected to match either correct GBIF or Clements checklist
3. scientific_name.checklist : final resolved name from GBIF to Clements checklist


*These are to be reviewed and kept or removed - they may not be needed*



### TYPOS


```{r}

int.raw.names <- add_name_edits(int.raw.names, 
    scientific_name.raw = "Duck sp.",
                         edit_notes = "KEEP RAW and edit Duck sp. = Anatidae sp.",
                         scientific_name.edit="Anatidae sp."
                         )

```



### Manual fixes after exploring the checklist 

```{r}
scientific_name.to_fix = "Parkesia noveboracensis notabilis"
filter(int.raw.names,scientific_name.raw==scientific_name.to_fix) 

```

```{r}
int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Parkesia noveboracensis notabilis",
                 scientific_name.edit = "Parkesia noveboracensis",
                 edit_notes = "ACCEPT CHANGE TO CLOSEST MATCH because BOW states 'No subspecies, following Eaton (1957a) and Molina et al. (2000).'. Common name in int.raw is Northern Waterthrush. 1 Parkesia noveboracensis notabilis Parkesia noveboracensis       0.899"
  )

```


**Unresolved by Matching: Argya affinis somervillei**

```{r}
intxns_by_species(int.raw,"Argya affinis somervillei")
```

```{r}
int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Argya affinis somervillei",
                 scientific_name.edit = "Argya striata somervillei",
                 edit_notes = "Update to checklist: BOW and checklist: 'Black-winged Babbler' is most likely Jungle Babbler (Black-winged) Argya striata somervillei match  Argya affinis somervillei"
  )


```



#### Accipiter Hawks

**TO-DO** consolidate all hawk updates into since table for readability

Accipiter atricapillus IF American Goshawk, then we can change it.  

All goshawk rows: 
```{r}
filter(int.raw.names, scientific_name.raw ==  "Accipiter atricapillus")
```

yes - no European Goshawk in our names

```{r}
  int.raw.names<- add_name_edits(int.raw.names,
                 scientific_name.raw = "Accipiter atricapillus", #  Note: need to ensure that is not European Goshawk.
                 scientific_name.edit = "Astur atricapillus",
                 edit_notes = "Listed as American Goshawk, now genus Astur (Clements 2024)"
  )

```



```{r}
  int.raw.names <-
    add_name_edits(int.raw.names, scientific_name.raw = "Accipiter cooperi",
                  edit_notes = "Typo and Checklist shows genus moved to Astur. (Clements 2024).",
                 scientific_name.edit = "Astur cooperii"
    ) 

```

Unidentified Accipiter species handled here, genus has expanded

??? Is "Aerospiza/Tachyspiza/Accipiter/Astur sp." on the checklist?

```{r}
int.raw.names <- add_name_edits(int.raw.names, 
                 scientific_name.raw = "Accipiter sp.",
                 scientific_name.edit = "Aerospiza/Tachyspiza/Accipiter/Astur sp.",
                 edit_notes = "Checklist has expanded this genus (Clements 2024) "
    ) 

```


typo 'hawl' in an unid column

```{r}
interaction_records_by_match(int.raw, 'hawl')
```


```{r}
int.raw.names <-
          add_name_edits(int.raw.names, 
                 scientific_name.raw = "unid. Accipiter hawl",
                 scientific_name.edit =  "Aerospiza/Tachyspiza/Accipiter/Astur sp.",
                 edit_notes = "typo, assign generic hawk group")
  

```









CHANGE TO CLOSEST MATCH: checklist says Corvus brachyrhynchos caurinus

there is a case to keep Corvus caurinus as a species...

https://bcbirds.bcfo.ca/wp-content/uploads/2021/11/butler.pdf

 "Corvus caurinus"
```{r}
int.raw.names[int.raw.names$scientific_name.raw =="Corvus brachyrhynchos caurinus",]
print(interaction_count_by_species(int.raw, "Corvus caurinus"))
checklist[checklist$scientific_name=="Corvus caurinus",]

```

  
```{r}
int.raw.names <- add_name_edits(int.raw.names,
    scientific_name.raw = "Corvus caurinus",
    edit_notes = "CHANGE TO CLOSEST MATCH: checklist Northwestern Crow Corvus brachyrhynchos caurinus checklist match  0.900468284",
    scientific_name.edit = "Corvus brachyrhynchos caurinus"
  )

```

Previously also corrected *Larus spp.*, but this is no longer in db

```{r}
int.raw.names[int.raw.names$scientific_name.raw =="Larus brachyrhynchos caurinus",]
print(interaction_count_by_species(int.raw, "Larus brachyrhynchos caurinus"))
```

CHANGE TO CLOSEST MATCH: checklist says Campylorhynchus brunneicapillus

```{r}
int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Campylorhynchos brunneicapillus",
                 scientific_name.edit = "Campylorhynchus brunneicapillus",
                 edit_notes = "CHANGE TO CLOSEST MATCH: checklist Cactus Wren Campylorhynchus brunneicapillus 0.900716846"
  )

```


```{r}
int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Cathartus aura",
                 scientific_name.edit = "Cathartes aura",
                 edit_notes = "CHANGE TO CLOSEST MATCH: checklist Cathartus aura Turkey Vulture  Cathartes aura  0.901098901"
  )

```


 Moticilla alba lugens = White Wagtail (Black-Backed), typo fix 

```{r}
int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Moticilla alba lugens",
                 scientific_name.edit = "Motacilla alba lugens",
                 edit_notes = "CHANGE TO CLOSEST MATCH:  checklist Moticilla alba lugens White Wagtail (Black-Backed) ->   Motacilla alba lugens   0.901587302"
  )

```

Moticilla alba ocularis = White Wagtail (ocularis), misspelled genus

```{r}
filter(checklist, scientific_name == "Motacilla alba ocularis")

int.raw.names <- add_name_edits(int.raw.names, 
                 scientific_name.raw = "Moticilla alba ocularis",
                 edit_notes = "CHANGE TO CLOSEST MATCH: checklist Motacilla alba ocularis White Wagtail (Ocularis), Pied Wagtail",
                 scientific_name.edit = "Motacilla alba ocularis",
                 common_name.edit = "White Wagtail (ocularis)"
  )

```


---





```{r}
int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Cuculus canorus telephonus",
                 scientific_name.edit = "Cuculus canorus telephonus",
                 edit_notes = "KEEP RAW: Cuculus canorus common_name = Common Cuckoo
BOW says 'sometimes separated subspecifically as telephonus on basis of size (smaller than subtelephonus) and pale plumage (like subtelephonus), but birds in this area are not constant in these characters and overlap with other races occurs'"
  )

```


Reconcile "Parkesia noveboracensis limnaeus"

number of interaction records with this species?

```{r}
print(interaction_count_by_species(int.raw,"Parkesia noveboracensis limnaeus"))
```


```{r}

int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Parkesia noveboracensis limnaeus",
                 scientific_name.edit = "Parkesia noveboracensis",
                 edit_notes = "CHANGE TO CLOSEST MATCH: BOW says No subspecies, following Eaton (1957a) and Molina et al. (2000). Hence, P. n. notabilis (Ridgway, 1880), P. n. limnaeus (McCabe and Miller, 1933), and P. n. uliginosus (Burleigh and Peters, 1948) are junior synonyms of P. noveboracensis (Gmelin, 1788).  0.906"
  )

```


```{r}

print(interaction_count_by_species(int.raw,"Zosterops lateralis gouldi"))

int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Zosterops lateralis gouldi",
                 scientific_name.edit = "Zosterops lateralis",
                 edit_notes = "CHANGE TO CLOSEST MATCH bc unresolved: BOW says: 
                 In Australia, birds previously known as race gouldi, but chloronotus has priority and not preoccupied by 'chloronothos'."
  )

```


CHANGE TO CLOSEST MATCH bc unclear: BOW: Mainland races tend to intergrade;intermediates between erythronotus and tricolor sometimes referred to as
'nigriceps', a name better applied to a 'swarm of intergrades' in NC India Lanius schach erythronotus/tricolor Lanius schach erythronotus       0.914

```{r}
interaction_count_by_match(int.raw,'erythronotus')
interaction_count_by_species(int.raw, "Lanius schach erythronotus/tricolor")
```

```{r}
int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Lanius schach erythronotus/tricolor",
                 scientific_name.edit = "Lanius schach erythronotus",
                 edit_notes = "CHANGE TO CLOSEST MATCH bc unclear: BOW: Mainland races tend to intergrade;intermediates between erythronotus and tricolor sometimes referred to as 'nigriceps', a name better applied to a 'swarm of intergrades' in NC India Lanius schach erythronotus/tricolor Lanius schach erythronotus 0.914"
  )

```



```{r}
int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Aphelocoma woodhouseii suttoni",
                 scientific_name.edit = "Aphelocoma woodhouseii suttoni",
                 edit_notes = "KEEP RAW for now because it is a subspecies: BOW: A. w. suttoni Phillips, 1965. "
  )
```




### THE FOLLOWING WAS COPIED INTO THE NOTES FILE



```{r}
# match with checklist

edits_by_scientific_name <- list(
    c("Acanthis flammea","Acanthis flammea hornemanni"),
    c("Accipiter bicolor","Astur bicolor"),
    c("Accipiter cooperii","Astur cooperii"),
    c("Accipiter gentilis laingi","Astur atricapillus laingi"),
    c("Accipiter gentilis","Astur atricapillus"),
    c("Accipiter melanoleucus","Astur melanoleucus"),
    c("Accipiter sp.","Aerospiza/Tachyspiza/Accipiter/Astur sp."),
    c("Aechmophorus occidentalis ephemeralis","Aechmophorus occidentalis"),
    c("Aechmophorus occidentalis occidentalis","Aechmophorus occidentalis"),
    c("Agelaioides badius fringillarius","Agelaioides fringillarius"),
    c("Ammospiza caudacuta caudacuta","Ammospiza caudacuta caudacuta"),
    c("Ammospiza caudacuta diversa","Ammospiza caudacuta diversa"),
    c("Schoeniparus castaneceps","Schoeniparus castaneceps"),
    c("Schoeniparus cinereus","Schoeniparus cinereus"),
    c("Schoeniparus dubius","Schoeniparus dubius")
)

for(edit in edits_by_scientific_name) {
  scientific_name.raw <- edit[1]
  scientific_name.edit <- edit[2]
  # check if it's on the checklist
  
  edit_note <- "Update to match checklist (Clements 2024)"
  ## check if the edited name is already correct!
  
  rows_in_names <- int.raw.names[int.raw.names$scientific_name.raw == scientific_name.raw,]
  if(nrow(rows_in_names)==0){
    paste(scientific_name.raw, "not on the list at all")
    next
  }
  
  for(i in 1:nrow(rows_in_names)){
    int.raw.name <- rows_in_names[r,]
    already_edited_name <- rows_in_names[1,]$scientific_name.edit
  
    if(already_edited_name == scientific_name.edit ) { 
      next
    } else {
      
      int.raw.names <- add_name_edits(int.raw.names,
                      scientific_name.raw,
                      edit_note,
                      scientific_name.edit)
    }
  }
}
  
```

#### Match to checklist based on common name. 

These could match multiple rows in names
table, but this won't update rows that already have the matching scientific name 
edit, so the note won't be over-written

```{r}

edits_by_common_name <- list(
    c("Acanthiza apicalis albiventris","Red-Tailed Thornbill"),
    c("Accipiter striatus venator","Sharp-Shinned Hawk (Puerto Rican)"),
    c("Aechmophorus clarkii clarkii","Clark's Grebe (clarkii)"),
    c("Aechmophorus clarkii transitionalis","Clark's Grebe (transitionalis)"),
    c("Aimophila ruficeps eremoeca","Rufous-Crowned Sparrow (Eremoeca)"),
    c("Aimophila ruficeps scottii","Rufous-Crowned Sparrow (Scottii)"),
    c("Ammospiza caudacuta caudacuta","Saltmarsh Sparrow (Caudacuta)"),
    c("Ammospiza caudacuta diversa","Saltmarsh Sparrow (Diversa)"),
    c("Schoeniparus castaneceps","Rufous-winged Fulvetta"),
    c("Schoeniparus cinereus","Yellow-Throated Fulvetta"),
    c("Schoeniparus dubius","Rusty-Capped Fulvetta")
)

for(edit in edits_by_common_name){
  print(edit)
  
  common_name.raw <- edit[2]
  scientific_name.edit <- edit[1]
  # check if it's on the checklist
  
  edit_note <- paste("Update to match checklist (Clements 2024) based on common name", common_name.raw)

  int.raw.names <- add_name_edits_by_common_name(int.raw.names, 
                       common_name.raw = common_name.raw,
                        edit_notes = edit_note,
                        scientific_name.edit = scientific_name.edit
  )
}
 
```


## Handle Genus sp. 

**Genus-level entries: **

December, 2024: 621
May 29, 2025: 626

```{r}

```



## Subset to the checklist 

This should go into a different script/notebook

Analysis Paper: 

1 sp1 and sp2 on checklist (canada CONUS)
Data Paper Goal: 

1. Sp1 or sp2 needs to be on Checklist (canada conus checklist)
2. Final check:which rows are not (sp1 AND sp2 on Canada Conus checklist)?
    how many?
    which of these are NOT on full clements list
    how many? 
    review data
    check against all clements
    assume names are fixed via gbif/taxa db
    
    if descions are made add name edits to be added to the int.raw.names list above



```{r}
#| label: subset_check
# rcode for above, prints a data frame of non-checklist rows
```

review data frame to make decisions

```{r}
# make additional edits using int.raw.names <- add_name_edits(...)
# re-run the block subset_check

```






```{r}
# # ... FINISH THIS LATER FOR OTHER non-BBS species
# 
# # For now, focus on BBS splist because need to get these data cleaned and
# # aligned for merging with bbs.obs for network modeling. Return to the cleaning
# # below after this is completed...
# 
# #******** BBS WORK **********# 
# # Merge scientific_name in splist with scientific_name in int.checklist
# # to check current common_name list and identify gaps and updates to
# # scientific_name. This will update most of the BBS species, but not necessarily the ones
# # outside of BBS. "scientific_name" = the names agreed upon by CHECKLIST and by
# # the GBIF-screened species. common_name = the CHECKLIST common_name.
# int.checklist <- subset(
#   int.checklist,
#   select = c("scientific_name", "common_name", "scientific_name.raw","scientific_name.edit")
# )
# dim(int.checklist)
# # 4576; 29 May 2025: 4551
# int.checklist <- int.checklist %>% 
#   distinct()
# dim(int.checklist)
# # 3915 OK; May 29, 2025: 3891
# length(unique(int.checklist$scientific_name.raw))
# # 3913 OK; May 29, 2025: 3889

```



### Subspecies

check if there are any subspecies remaining that have interactions

for those, decide what to do with them if they exist, potentially publish in the 
database


```{r}
#| eval: false

# PARKING LOT FOR CONTINUED CLEANING...

# Hoary Redpoll lumped into Redpoll, but not sure this is the case in the BBS...
# bbs.splist$scientific_name[bbs.splist$scientific_name.bbs2024 == "Acanthis
# flammea"] <- "Acanthis flammea hornemanni"

```


### Work through hybrids 

```

Hybrids to standardize: 
  
  TO-DO: keep them in the database, but fix only the following 

  Hybrid Bullock's Oriole X Baltimore = Oriole Icterus bullockii x galbula
  Hybrid Western Gull X Glaucous-Winged Gull = Larus occidentalis x glaucescens
  Hybrid Barnacle X Bar-Headed Goose = Branta leucopsis x anser indicus

dplyr::filter(int.raw, species1_scientific %in% c("Branta leucopsis x"))
# NO HYBRIDS IN CLEANED DATA NOW
dplyr::filter(int.raw, species1_scientific %in% c("Branta leucopsis x Anser indicus"))
dplyr::filter(int.raw, species2_scientific %in% c("Branta leucopsis x Anser indicus"))
# dplyr::filter(unresolved.gbif, scientific_name.edit %in% c("Branta leucopsis x anser indicus"))
# dplyr::filter(unresolved.gbif, scientific_name.edit %in% c("Branta leucopsis x anser indicus"))
# fixed_names1$scientific_name[fixed_names1$scientific_name.edit == "Branta leucopsis x anser indicus"] <- "Branta leucopsis x Anser indicus"
```



## Merge and Save data

Update the scientific names in the interactions data with our table as much 
as possible

```{r}

int.raw.resolved <- int.raw

updated_rows <- c()

for(r in 1:nrow(int.raw.names.checklist)){
  # if no resolution discovered, skip (for now - ultimately all are updated)
  if(is.na(int.raw.names.checklist[r,"scientific_name.checklist"])){
    next
  }
  
  # extract values from data frame for readability
  scientific_name.raw <- int.raw.names.checklist[r,]$scientific_name.raw
  scientific_name.checklist <- int.raw.names.checklist[r,]$scientific_name.checklist
  common_name.checklist <- int.raw.names.checklist[r,]$common_name.checklist
  
  # if no change, then skip since don't need to update the row
  if( scientific_name.raw  == scientific_name.checklist ){
    next
  }
  
  # update sp1s and sp2s
  # use matches from original dataframe but update our resolved data frame 
  # since the rows are the same order and number 
  # this allows for matching on the raw sci name for common name updates, 
  # even after it's been updated
  
  updated_sp1_rows = which(int.raw$species1_scientific == scientific_name.raw)
  if(length(updated_sp1_rows) > 0){
    int.raw.resolved[updated_sp1_rows, ]$species1_scientific <- scientific_name.checklist 
    int.raw.resolved[updated_sp1_rows, ]$species1_common <- common_name.checklist
    updated_rows <- union(updated_rows, updated_sp1_rows)
  }

  updated_sp2_rows = which(int.raw$species2_scientific == scientific_name.raw)
  if(length(updated_sp2_rows) > 0){
    int.raw.resolved[updated_sp2_rows, ]$species2_scientific <- scientific_name.checklist 
    int.raw.resolved[updated_sp2_rows,  ]$species2_common <- common_name.checklist
    updated_rows <- union(updated_rows, updated_sp2_rows)
  }
  
}

print(length(updated_rows))
```

Save Results to CSV

```{r}
#| label: save_output
#| echo: false
#| output: true

# set these variables here for flexibility if the workflow changes 
interaction_data <- int.raw.resolved
taxonomic_resolutions<- int.raw.names.checklist

# AvianInteractionData_L1_file and AvianInteractionData_L1_taxonomy_table is set at the top of this file

f <- file.path(file_paths$L1, AvianInteractionData_L1_file )
write_csv(interaction_data, f)
print(paste("interaction database saved to ", f))

f<- file.path(file_paths$L1,taxonomic_resolutions_file_name)
write_csv(taxonomic_resolutions, f)
print(paste("taxonomic_resolutions_file saved to ", f))

```

```


```{r}
# Summary info before exporting - replace DATA with data object name
print("unique scientific names = number of unique species in this database")
print(length(unique(paste(DATA$species1_scientific, DATA$species2_scientific))))

print("unique types of interactions")
print(length(unique(DATA$interaction)))

print("unique pairwise interactions")
# edit to report number of unique rows by DATA$species1_scientific, DATA$species2_scientific, DATA$interaction

```
