
---
title: "L1 taxonomic harmonization"
author: 
  - Phoebe L. Zarnetske
  - Patrick Bills
format:
  html:
    toc: true
    toc-depth: 3
    embed-resources: true
editor: source
date: 09/01/2025
date-format: iso
---

## Avian Interaction Pairs Data: L0 to L1 taxonomic harmonization

### About

**PROJECT:** Avian Interaction Database

**COLLABORATORS:** Vincent Miele, Stephane Dray, Emily Parker

**Run Date:** `r Sys.Date()`

### Data input:


*Set the interactions database file to read from here:*

( output From `R/L0/AvianInteractionData_L0_stitch.R` )

```{r}
stitched_L0_file <- "AvianInteractionData_L0_stitch.csv" 
```


Main Checklists:

- Full Clements/Ebird list 
- GBIF database (via taxadb package)

Curated Species checklist: 

- Current selected species list
  combined checklist based on Clements/Ebird, Avibase, 
  output from `R/L0/AvianInteractionData_specieslists_L0.R`
  - used for species lookup / matching


### DATA OUTPUT:

L1 data: `int.namefix.bbs.RData` 


### Next script to run: 

`AvianInteractionData_L1_post_taxa_cleaning.R`

*most of the cleaning functions have been moved to L0 scripts*

### NOTES

This script is used to refine species name changes to align with the 
Clements & eBird checklist to create an Rdata file.  

Currently, the script is working for a checklist of CONUS+Canada.  

L0 data are checked to assign updated scientific and common names to the interaction pairs data. Makes a new column that also includes scientific name changes associated with the AOUcombo.index for merging with those names in the AvianInteractionData_AOUindex_L1.csv

Notes Meaning: "keep raw and edit..." generally means " don't use one of the 
results of the matching algorithms, but instead replace w/Clements2024:..."

GOOD EXAMPLE TO TRACE MATCHING: Aeronautes saxitalis should be Aeronautes saxatalis

### Versions

-   Original R script `AvianInteractionData_L1.R` 27 Oct 2022 (PLZ)
-   updated through 12 Dec 2024 (PLZ);
    -   As of Dec. 12, 2024, this is mainly cleaned for BBS species
-   May 2025- July 2025 convert to notebook/Quarto, (PSB)
-   August 2025, using new species lists Canada+Conus from PLZ (PSB)
-   September 10, 2025, using species lists from commit from plz (PSB)


## TO DO / Notes


somehow Duck sp  is making it through L0 instead of Duck sp.

the low-confidence (and maybe some high confidence?) matches sometimes
give the result as an unid ( Astur sp. ) which then removes the species. 
these are sometimes caught later but really should be filtered out from the 
low-confidence match process and discovered/fixed later






## Set-up

File paths used for this run:

```{r}
#| echo: false

# functions used by all 
source(here::here('R/L0/L0_functions.R'))
# functions for this process to reduce this script size
# and load libraries used here
source(here::here('R/L1/L1_taxonomy_functions.R'))

file_paths <- get_file_paths()

print(file_paths)
```

*Note that the Checklist folder above is in L0 which contains species lists, 
but the subset list for 2024-25 analysis is in L1 as it's built from L0 lists*






--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Checklists

### Curated List

**Previously:** all species in BBS `"bbs_splist_2024_L1.csv"`

(the 2024 release which includes all species as of 2023, plus the additional 
AOUcombo.index column for use w BBS index)

`splist2024<-read.csv(file.path(L1_dir,"bbs_splist_2024_L1.csv"))`

**Current**

September 2025: new curated list curated by PLZ using Clements, AVIBase, BBS etc. 
See `R/L1/AvianInteractionData_specieslists_Canada_CONUS_L1.R`

```{r}
current_species_list_filename <- "canada.conus.splist_L1.csv"
splist2024_filepath <- file.path(file_paths$L1,"species_checklists",current_species_list_filename )
splist2024 <- read.csv(splist2024_filepath)
print(paste("Read in ", nrow(splist2024), "entries from checklist file", splist2024_filepath))

```

Optionally explore this list

```{r}

tibble(splist2024)
```

Fieldnames of Species List:

```{r}
#| echo: false
print(names(splist2024))
```

### Main Checklist

Read in the full check list the official eBird/Clements checklist

```{r}
checklist_filename <- "eBird-Clements-v2024-integrated-checklist-October-2024-rev.csv"
checklist.orig <- read.csv(file.path(file_paths$CHECKLIST_FOLDER,checklist_filename))
print(paste("Read in ", nrow(checklist.orig), "entries from checklist file", checklist_filename))
```

amend column names of checklist to match for merging later show col name before and after change

```{r}
print(names(checklist.orig))
checklist <- checklist.orig
names(checklist)[names(checklist) == "scientific.name"] <-"scientific_name"
names(checklist)[names(checklist) == "English.name"] <-"common_name"
print("CORRECTED CHECKLIST COLUMNS:")
print(names(checklist))
```

We are using the GBIF list (via taxadb) to resolve scientific names and the 
eBird/Clements checklist via Birds of The World naming conventions for species. 
Some BBS names differ from these lists so they have to be resolved manually.



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
## Interactions Data

To use a different or test files, edit this L0 filename:

```{r}
stitched_L0_file<- "AvianInteractionData_L0_stitch.csv"
full_path_stitched_file <- file.path(file_paths$L0,stitched_L0_file)
int.raw<-read.csv(full_path_stitched_file)
print(paste("read in ", nrow(int.raw), "records from ", full_path_stitched_file))
```

### Final Interaction Data Cleaning/Corrections

Most of these filters and adjustments are now made during the L0_stitch process
but were are ensuring the data is clean prior to matching taxonomy


### Remove blank rows

```{r}
before_filter_nrow <- nrow(int.raw)
int.raw <- filter(int.raw,!(is.na(species1_scientific)& 
                             is.na(species2_scientific) & 
                             is.na(species1_common) & 
                             is.na(species2_common)
                           ))

print( paste(as.integer(before_filter_nrow - nrow(int.raw)), "blank rows removed"))
```

### Trim white space from all names columns

```{r}
# trim white space

int.raw <- dplyr::mutate(int.raw, 
                         species1_scientific = trimws(species1_scientific,which=c("right")), 
                         species2_scientific = trimws(species2_scientific,which=c("right")), 
                         species1_common = trimws(species1_common,which=c("right")),
                         species2_common = trimws(species2_common,which=c("right"))
) 

print("unique scientific name combos after removing white space")
print(length(unique(paste(int.raw$species1_scientific, int.raw$species2_scientific))))
```

### Missing Scientific name check

Are there any records that are missing a scientific name for species1?

*if so this is problematic for adjusting the recorded name with the checklist 
name, and should be corrected in data entry files*

```{r}
records.missingsp1 <- int.raw[is.na(int.raw$species1_scientific),]
tibble(records.missingsp1)
```

Records missing a scientific name for sp2

```{r}
records.missingsp2 <- int.raw[is.na(int.raw$species2_scientific),]
tibble(records.missingsp2)

```



Are there rows that have *only* common names for both sp1 and sp2?

```{r}
 
int.common_names_only <- dplyr::filter(int.raw, is.na(species1_scientific) & is.na(species2_scientific))
  
print(nrow(int.common_names_only))
```

### remove rows that do not have interactions

*These should be corrected in the L0 correct process, 
but catch them here before correcting taxonomy*


List rows with both interaction columns missing

```{r}
#| echo: false
# to allow us to re-run this, look to see if we saved the var with all rows
# because we've run the cells below, and if so, reset our main df to that one
if(exists("int.raw.saved_all_rows")) int.raw<- int.raw.saved_all_rows

print("n rows with both effects missing:")
print(nrow(filter(int.raw, is.na(effect_sp1_on_sp2) & is.na(effect_sp2_on_sp1))))
print("n rows with at least on effect present:")
print(nrow(filter(int.raw, !is.na(effect_sp1_on_sp2) | !is.na(effect_sp2_on_sp1))))
print("list of rows with both effects missing:")
```

Table of rows with both effects missing:

```{r}
#| echo: false

tibble(filter(int.raw, is.na(effect_sp1_on_sp2) & is.na(effect_sp2_on_sp1)))
```

Remove those with no interactions (if any)
```{r}

# save the original full list in case we need to check again
int.raw.saved_all_rows <- int.raw

int.raw <- filter(int.raw, !is.na(effect_sp1_on_sp2) | !is.na(effect_sp2_on_sp1))
print("rows remaining with not both effects NA:")
print(nrow(int.raw))
```

### Some quick typo fixes

This is the same function run during stitching, but run it again and to create
a cleaned L0 data set to work with 

```{r}

int.raw<-fix_taxon_typos(int.raw)

```
### Discovery and repair of missing Sp1/Sp2 scientific names

List rows with missing sp1 values but have other data to use for fix

```{r}
records.missingsp1 <- int.raw[is.na(int.raw$species1_scientific),]
print(records.missingsp1)
```

Fix these missing species directly by matching the common_names from checklist

```{r}
#| echo: false
 
for(common_name_for_missingsp1  in records.missingsp1$species1_common){
  print(common_name_for_missingsp1)
  
  matching_sp<- checklist %>% 
    dplyr::filter(common_name == common_name_for_missingsp1) %>% 
    dplyr::select(common_name, scientific_name)  
  
  print(as.vector(matching_sp[1,]$scientific_name))
  # print(subset(checklist, common_name == common_name_for_missingsp1))
}
```


Assign scientific names to all rows for those common names 
that have missing sp1 scientific names, create a Manual Assignment structure 
here

```{r}
#| echo: false
manual_assignments = list()
manual_assignments[["Rhinoceros Auklet"]] <- "Cerorhinca monocerata"

print(manual_assignments)
# add more as needed  
```

apply the manual assignments

```{r}
for(cname in names(manual_assignments)){
  print(paste("set records with common name", cname, "to sp1 = ", manual_assignments[[cname]]))
  print("n rows to update:")
  print(nrow(int.raw[int.raw$species1_common == cname & is.na(int.raw$species1_scientific),]))
  int.raw[
    int.raw$species1_common == cname & 
    is.na(int.raw$species1_scientific),
    ]$species1_scientific = manual_assignments[[cname]] 
}

  
```

double check: remaining records with **missing sp1:**

```{r}
records.missingsp1 <- int.raw[is.na(int.raw$species1_scientific),]
print(records.missingsp1)  
```

### Discovery and repair of missing Sp2 scientific

rows with missing **sp2 scientific**:

```{r}
records.missingsp2<- int.raw[is.na(int.raw$species2_scientific),]
print( records.missingsp2)
```


Saved outcome from Previous run
```         
May 2025: 2 rows need editing 
species1_common species2_common         species1_scientific
866         White-cheeked Pintail   Cinnamon Teal Anas bahamensis rubirostris
14223 Middle American Screech-Owl            <NA>        Megascops guatamalae
species2_scientific effect_sp1_on_sp2 effect_sp2_on_sp1          interaction
866                  <NA>                 1                 1 facilitation-feeding
14223                <NA>                NA                NA                 <NA>
one had both NA interactions , now we are removing those
```



List the names from the checklist that match those missing in sp2:

```{r}
#| echo: false
#| 
for(common_name_for_missingsp2  in records.missingsp2$species2_common){
  print(checklist %>% 
    dplyr::filter(common_name == common_name_for_missingsp2) %>% 
    dplyr::select(common_name, scientific_name))
}
```

**Sp2 fix list**

update this list of fixes as errors are discovered above

Note that the common names will be update updated below with the checklist

```{r}
#| echo: false
manual_assignments = list()
manual_assignments["Cinnamon Teal"] <-  "Spatula cyanoptera"
# add more as needed  
print(manual_assignments)
```

fix sp2 using the list above

```{r}
# species2 fixes using the list above
for(cname in names(manual_assignments)){
  print(paste("set records with common name", cname, "to sp2 = ", manual_assignments[[cname]]))
  print("n rows to update with this command name and missing sp2:")
  rows_to_fix <- nrow(
    int.raw[int.raw$species2_common == cname & is.na(int.raw$species2_scientific),]
  )
  
  print(rows_to_fix)
  if(rows_to_fix > 0 ){
  int.raw[
    int.raw$species2_common == cname & 
    is.na(int.raw$species2_scientific),
    ]$species2_scientific = manual_assignments[[cname]] 
  }
}
  # double remaining rows with missing sp2 (should be zero)
```

Double check that there are no remaining rows with missing scientific names

```{r}
tibble(int.raw[is.na(int.raw$species2_scientific),]) 
```
*completed fixes for missing scientific names*








--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Taxonomy Adjustments Table

**Create new data frame of all names, as is in the raw file, and what is to be 
adjusted/updated/assigned


Column Definitions:

- scientific_name.raw : L0 name as it appears in the original CSV file (stitched)
- common_name.raw : L0 name as it appears in the original CSV file (stitched)
- scientific_name_clements2024 : L1 name to be used (pre checklist )
- common_name_clements2024 : L1 name to be used (pre checklist )
- edit_notes: text of why edits were made

The edit columns are based on Clements 2024
Determine how many unique entries are in int.raw\$species1_scientific , which 
are unique combos of scientific names

```{r}
unique.sp.raw <- data.frame(scientific_name.raw = with(int.raw, union(
  species1_scientific, species2_scientific
)))

print(dim(unique.sp.raw)) #3913 # May 29, 2025: 3889
```



### Create Name Edits Table

Create list of unique scientific_name.raw and common_name.raw pairs with 
formatting adjustments, stacking and collecting anything in sp1 and sp2. 
See documentation in `L1_taxonomy_functions.R` script for details

*note:  since adjustments/corrections to species were added to L0 cleaning 
process, there should be very few differences between 'raw' and 'edited' 
names at this point in the process*


```{r}
## create the raw <- edit adjustments table 
int.raw.names <- create_names_edit_table(int.raw)
head(tibble(int.raw.names))
```


Number of unique entries in raw sci names

```{r}

print(length(unique(int.raw.names$scientific_name.raw)))
# May 2025: 3889
```


**How many entries did the editing above fix?**


Number of scientific names that were 'edited' by this process (raw != edited):
```{r}
print(nrow(filter(int.raw.names, scientific_name.raw != scientific_name.edit)))
tibble(filter(int.raw.names, scientific_name.raw != scientific_name.edit))

```
Number of common names that were 'edited' by this process (raw != edited):
```{r}
print(nrow(filter(int.raw.names, common_name.raw != common_name.edit)))

```
Number of common names that are different not because of Upper case
```{r}
print(nrow(filter(int.raw.names, toupper(common_name.raw) != toupper(common_name.edit) )))

```
If zero above, then the only 'edits' for common name for upper/lower case matching



Test case to track with knonw misspelling: Accipiter cooperi was misspelled ( should be Accipiter cooperii) - exists in int.raw.names

```{r}
tibble(dplyr::filter(int.raw.names, scientific_name.raw %in% c("Accipiter cooperi")))
```

expected output:

```         
scientific_name.raw common_name.raw scientific_name.edit common_name.edit
1 Accipiter cooperi   Cooper's Hawk  Accipiter cooperi    Cooper's Hawk
```


**Side note: Accipiters are off (these are original raw data entries without taxonomic change)**

```         
scientific_name.raw      common_name       scientific_name
1    Acanthis flammea   Common Redpoll    Acanthis flammea
2 Acanthis hornemanni    Hoary Redpoll Acanthis hornemanni
3  Accipiter cooperii    Cooper's Hawk  Accipiter cooperii
4  Accipiter gentilis Northern Goshawk  Accipiter gentilis
5  Accipiter gentilis Northern Goshawk  Accipiter gentilis
6  Accipiter gentilis          Goshawk  Accipiter gentilis
```




--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


### TaxaDB

taxadb package: Modified from this code:
https://docs.ropensci.org/taxadb/articles/intro.html 
In previous code, tried ITIS and COL to see if they were better than GBIF. 
GBIF has the fewest NA values, so we are sticking with it (it is the most comprehensive).

#### Create a local GBIF database

Create a local gbif database in :
```{r}
taxadb::td_create("gbif")
```

Resolve scientific names for the scientific names, 
based on scientific_name.edit using GBIF

```{r}
int.gbif.names <- int.raw.names %>%
  mutate(
    scientific_id = taxadb::get_ids(scientific_name.edit, "gbif"),
    accepted_scientific_name = taxadb::get_names(scientific_id, "gbif")
  )
warnings()
```
**LIST JOIN WARNINGS => ISSUES TO FIX**

For those entries that are ambiguous (\> 1 match of the edited species with gbif),
a warning will be issued. This loops through those warnings and prints 
the message that has the species in question so we can view and capture it.

```{r}
  ws<- dplyr::last_dplyr_warnings()
  print(paste("there are ", length(ws), "species have >1 identifier and need to be resolved w BOW"))

  for( w in ws) print(w$parent)
```


```{r}
  duplicated_names <- list(
  'Anser anser anser',
  "Eudynamys orientalis",
  'Larus fuscus fuscus',
  'Psittacula eques',
  'Anas poecilorhyncha'

  )
for(species in duplicated_names){
  print(species)
  print(tibble(int.raw[int.raw$species1_scientific == species | int.raw$species2_scientific == species, ]))
  
  # tibble(checklist[which(checklist$scientific_name == species), ])
}
  
  
```

Show the Clements checklist entries for these:

```{r}
  #| echo: false
  
  options(tibble.width = 200) 
  tibble(checklist[which(checklist$scientific_name %in% duplicated_names), ])
```

```{r}

# optionally look through the full list of names
# tibble(int.gbif.names)
```

### Notes on dispensation of names with ambigous checklist items

Adjust this text to indicate decision on the species above
Species to keep as is (e.g. KEEP RAW)

```{r}

# barring code to pull those names automatically, add fixes for these 
# manually here

#  Common name changes will be fixed later, below, with merging.

int.raw.names <- int.raw.names  %>% 
                add_name_edits("Anser anser anser", 
                    edit_notes = "KEEP RAW, European Graylag Goose; checklist common_name: Graylag Goose (European)") %>% 
                add_name_edits("Eudynamys orientalis", 
                  edit_notes = "KEEP RAW Eudynamys orientalis - Pacific Koel; same as checklist common_name") %>%
                add_name_edits("Larus fuscus fuscus", 
                  edit_notes = "KEEP RAW  Lesser Black-backed Gull checklist common_name: Lesser Black-backed Gull (fuscus)") %>%
                add_name_edits("Psittacula eques", 
                  edit_notes = "KEEP RAW Echo Parakeet") %>%
                add_name_edits("Anas poecilorhyncha",
                  edit_notes = "KEEP RAW  Indian Spot-billed Duck : checklist common_name: Indian Spot-billed Duck")


```


**NOTES** 
*the following were dealt with in a previous version of this code but keeping this
note here to track that for future reference.  need to check that status**

``` 
# KEEP RAW - Batis molitor - Chinspot Batis
# checklist common_name: Chinspot Batis

# KEEP RAW - Heteromyias armiti - Black-capped Robin
# checklist common_name: Black-capped Robin

# KEEP RAW - Chloris sinica - Oriental Greenfinch
# checklist common_name: Oriental Greenfinch

# KEEP RAW - Passer cinnamomeus - Russet Sparrow
# checklist common_name: Russet Sparrow

# KEEP RAW - Turdus nudigenis - Spectacled Thrush
# checklist common_name: Spectacled Thrush


# KEEP RAW - Anas flavirostris - Yellow-billed Teal
# checklist common_name: Yellow-billed Teal

```

```{r}

int.raw.names<- add_name_edits(int.raw.names,scientific_name.raw = "Anas poecilorhyncha",
                edit_notes = "KEEP RAW  Indian Spot-billed Duck : checklist common_name: Indian Spot-billed Duck")
```


#### Example Checking process: **Pine Warbler** - this is also dealt with below

CHANGE TO NEW NAME below: Dendroica pinus - Pine Warbler

checklist common_name: Pine Warbler; scientific_name = Setophaga pinus

checklists for the old and then new name FOR THIS SPECIES


is this is being used? records with old name: 
```{r}
dplyr::bind_rows(
  dplyr::filter(int.raw, species1_scientific %in% c("Dendroica pinus")),
  dplyr::filter(int.raw, species2_scientific %in% c("Dendroica pinus"))
)
```
records with new name:
```{r}
sp_sci_name<- "Setophaga pinus"
dplyr::bind_rows(
  dplyr::filter(int.raw, species1_scientific %in% c(sp_sci_name)),
  dplyr::filter(int.raw, species2_scientific %in% c(sp_sci_name))
)
```

Which is preferred on the checklist?
```{r}
checklist[which(checklist$scientific_name == "Dendroica pinus"), ] # no records
checklist[which(checklist$scientific_name == "Setophaga pinus"), ] # one record
```

Is there an entry in our name edit table with the old genus?
```{r}
tibble(int.raw.names[int.raw.names$scientific_name.raw == "Dendroica pinus",])
```

add edited name and note

```{r}
int.raw.names <- add_name_edits(edits.df = int.raw.names,
               scientific_name.raw = "Dendroica pinus", 
               scientific_name.edit = "Setophaga pinus",
               edit_notes = "Update to new checklist name"
)
```

*Note this is also handled below in slightly different way*

**COMPLETED: NON-STANDARD ADJUSTMENTS POST-TAXA-DB**


## TaxaDB/GBIF Edits notes 

** ???PLZ  this whole section might be skippped 

check after fixing mixed matches

rows of gbif names vs int.raw.names 

*should be the same as it includes non-matches, confirms function worked correctly*

```{r}

print(nrow(int.gbif.names))
print(nrow(int.raw.names))
# 5343; May 29, 2025: 5318
  
```

Number of unique scientific names found for raw name entries:

due to common name duplications or spelling differences

```{r}
print(length(unique(int.gbif.names$scientific_name.raw)))

# 3913; May 29, 2025: 3889 OK       
```


Separate resolved and unresolved names based on specified criteria

Number of resolved names via gbif:

 
```{r}
# gbif matched have a scientific_id value
# ensure to not include genus-only entries as GBIF matched

resolved.gbif <- filter(int.gbif.names, 
  !is.na(scientific_id) | grepl(" sp\\.$", scientific_name.edit)) 

print(length(unique(resolved.gbif$scientific_name.raw)))
print("of")
print(length(unique(int.raw.names$scientific_name.raw)))
# 3587; May 29, 2025: 3580
```


Number and percent of unresolved GBIF names: 

*those full species (not unid.) that don't match*

```{r}
#| echo: false
unresolved.gbif <- int.gbif.names %>%
  filter(is.na(scientific_id) & !grepl(" sp\\.$", scientific_name.edit))

print(length(unique(unresolved.gbif$scientific_name.raw)))

sprintf("%.2f%%",
        round( 
          length(unique(unresolved.gbif$scientific_name.raw)) /  
          length(unique(resolved.gbif$scientific_name.raw)), 4) * 100
      ) 

# 326; May 29, 2025: 309

```

Number of un-id names (genera only, not expected to Taxadb to match, just accounting):

```{r}
int.raw.names.unid <- filter(int.raw.names, grepl(" sp\\.$", scientific_name.edit))
print(paste("rows:", nrow(int.raw.names.unid)))
print(paste("unique:", length(unique(int.raw.names.unid$scientific_name.edit))))

```


Test: Accipiter cooperi is misspelled
```{r}
dplyr::filter(resolved.gbif, scientific_name.raw %in% c("Accipiter cooperi"))
# doesn't exist
```

Test: Accipiter cooperi is misspelled - exists in unresolved.gbif

```{r}
dplyr::filter(unresolved.gbif, scientific_name.raw %in% c("Accipiter cooperi"))
# scientific_name.raw common_name.raw scientific_name.edit common_name.edit scientific_id
# 1 Accipiter cooperi   Cooper's Hawk  Accipiter cooperi    Cooper's Hawk          <NA>
#   accepted_scientific_name
# 1                     <NA>
```


## Add Edit and Note for all TaxaDB GBIF matches 

Indicate in the names table which have valid GBIF names (may or may not be 
checklist names) but don't overwrite existing notes

how many rows have notes? even if small, we want to keep those.  note this 
must be run prior to work done below.  

```{r}
#| echo: false

noted_so_far <- length(which(int.raw.names$edit_notes!= ""))
noted_so_far
```


For those that matched in gbif AND not already have an note, add note including
the GBIF ID number that matched.  

```{r}
# this is maybe not the most R way to do this
# find the rows in our names that matched GBIF, and take out the rows that already 
# have a note in them, and update all of those notes
rows_that_have_gbif_match <- which(!is.na(int.gbif.names$scientific_id))##  match(resolved.gbif$scientific_name.raw, int.raw.names$scientific_name.raw)
rows_with_non_empty_notes <- which(!is.na(int.raw.names$edit_notes))

rows_to_update <- rows_that_have_gbif_match[! rows_that_have_gbif_match  %in% rows_with_non_empty_notes ]

for(r in rows_to_update){
   if ( int.raw.names[r,]$scientific_name.edit != int.gbif.names[r, "accepted_scientific_name"]){
     warning(paste(int.raw.names[r,]$scientific_name.edit, "did not match gbif name"))
   }
   int.raw.names[r,]$edit_notes <- paste('KEEP RAW, matched GBIF to ', as.character(int.gbif.names[r,"scientific_id"]))
}
```

### Remaining unresolved by GBIF

check our count

```{r}
print("total rows in names needing resolution")
nrow(unresolved_species(int.raw.names))
print("unique sci names needing resolution")
print(length(unique(unresolved_species(int.raw.names)$scientific_name.raw)))
print("unresolved gbif")
print(length(unique(unresolved.gbif$scientific_name.raw)))


```

The 'unresolved gbif' count includes those rows that already had dispensation
notes (about 6 in 2025)


```{r}
#| echo: false

# remove empty columns
# Omit scientific_id and accepted_scientific_name since they are blank

unresolved.gbif$scientific_id<-NULL
unresolved.gbif$accepted_scientific_name<-NULL

```







--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Fuzzy Matching of Scientific Name to checklist

**Resolve unresolved GBIF**


Work with unresolved.gbif to try and determine what misspellings exist in the scientific_name.raw, and what they should be, based on the reference list from eBird & Clements CHECKLIST 2024.


Use fuzzy logic function ( see L1_taxonomy_functions.R ) to find closest match from the CHECKLIST reference list
Function to find the closest match with a similarity score, and ignoring the
name aspects above.

#### Reference list of scientific names from eBird Clements CHECKLIST 2024**

Create a reference list from our Checklist read in above (Clements)

```{r}
reference_names <- tibble(
  scientific_name = checklist$scientific_name,
  common_name = checklist$common_name
)
nrow(reference_names)

```

### Resolve matches based on scientific_name.edit and Clements Checklist

Calculate the fuzzy match score and closest name in the checklist for 
each record in the unresolved names

*(this takes several minutes to complete)*

```{r}

# reminder unresolved.gbif are those rows not matched by gbif and not unid Genus sp.

# saved previous version, which runs matching function twice and takes a while
# scientific_name_matches <- unresolved.gbif %>%
#  rowwise() %>%
#  mutate(
#    closest_scientific_name_match = find_closest_match_with_score(scientific_name.edit, checklist$scientific_name)$match,
#    scientific_name_match_score = find_closest_match_with_score(scientific_name.edit, checklist$scientific_name)$score
#  ) %>%
#  ungroup()

# refactored version using loop instead of rowwise, runs ~ 3X faster
scientific_name_matches <- unresolved.gbif
# add new columns
scientific_name_matches$closest_scientific_name_match <- NA
scientific_name_matches$scientific_name_match_score <- NA
# fill them in one row at a time
for(r in 1:nrow(scientific_name_matches)) {
  # optional, print the name we are on to gauge progress
  # print(scientific_name_matches[r,"scientific_name.edit"])
  fuzzy_match <- find_closest_match_with_score( scientific_name_matches[r,"scientific_name.edit"], checklist$scientific_name)
  scientific_name_matches[r,]$closest_scientific_name_match <- fuzzy_match$match
  scientific_name_matches[r,]$scientific_name_match_score <- fuzzy_match$score
}

# idea to improve speed: rewrite scientific_name_matches to accept a vector/list of names 
# and return list of lists, then rbind/cbind

tibble(scientific_name_matches)
```

Test of checklist and data : Accipiter cooperi is misspelled
- should have a match of about 0.89

```{r}
incorrect_sp_to_check <-"Accipiter cooperi" 
print(dplyr::filter(scientific_name_matches, 
                    scientific_name.raw %in% c(incorrect_sp_to_check))$scientific_name_match_score)
```

Species to check: should match with 1.0
```{r}
sp_to_check <- "Horornis flavolivaceus vulcanius"
dplyr::filter(scientific_name_matches, scientific_name.raw %in% sp_to_check)$scientific_name_match_score

```


---

## Scientific Name Changes: High & Low Confidence Matches

Number of unique scientific_name.raw in matches table:
```{r}
#| echo: false
print(Sys.Date())
print("")
print(length(unique(scientific_name_matches$scientific_name.raw)))
```

*Previous results of this check*
```
326 OK because it matches the unresolved.gbif number
May 29, 2025: 309 (unresolved.gbif =328)
```


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Scientific Name Fixes: high confidence matches


set high confidence threshold  (>=)

```{r}
high_confidence_threshold <- 0.9
```

Number of high confidence matches (scientific_name_match_score > 0.90)

```{r}
#| echo: false
high_confidence_matches <- scientific_name_matches %>%
  filter(
    scientific_name_match_score >= high_confidence_threshold 
  )
print(length(unique(high_confidence_matches$scientific_name.raw)))
```
*previous results:*

`Dec 2024: 257 out of 326; May 29, 2025: 244 out of 309`

### Determine lower confidence threshold

to find Define range for printing in increments of 0.005

use the scientific_name match. 

store each partition data.frame as an item in a list keyed on upper range

```{r}
score_start <- min(high_confidence_matches$scientific_name_match_score)
score_end <- max(high_confidence_matches$scientific_name_match_score)
increment <- 0.005

# collect these in a list for exploring
confidence_partition <- list()

# Loop through each score range and print the matches within that range
for (i in seq(score_start, score_end, by = increment)) {
  current_range <- high_confidence_matches %>%
    filter(scientific_name_match_score >= i & scientific_name_match_score <= i + increment)
  
  # Print the current range if it has any entries
  if (nrow(current_range) > 0) {
    low_range <- sprintf("%.2f", i)
    high_range <- sprintf("%.2f", i + increment)
    range_text = paste(low_range, "to", high_range)
    print(paste("Match Score Range:",range_text ,": ", nrow(current_range), "records"))
    confidence_partition[[high_range]]<- current_range
    # print(current_range, n=100) # print up to 100 rows in a section
  }
}

```
View any of these dataframes using the partition list to see what's on there
```{r}
 confidence_partition[["0.91"]]
```

For most of the names, the match is 1 or quite high, so assign them the
closest match, then edit the few below noted "KEEP RAW".

```{r}
print(length(unique(high_confidence_matches$scientific_name.raw)))
tibble(high_confidence_matches) %>% arrange(scientific_name_match_score)
```

*previous results*
```
257 out of 326; May 29, 2025: 244
```

Test: Accipiter cooperi is misspelled - not high confidence here... 
because < threshold and because on the checklist we are comparing too, 
the genus is changed...


```{r}
dplyr::filter(high_confidence_matches, scientific_name.raw %in% c("Accipiter cooperi"))
```


### Assign scientific_name and common_name

to the closest_matches based on fuzzy coding match. 

Dec. 11, 2024: only doing scientific_name for now.

---

## CHECKPOINT: save current workspace with current date

```{r}

today_date_string <- format(Sys.Date(),"%Y-%m-%d")
rdata_file_name <- paste0("AvianInteractionData_L1_workspace", today_date_string, ".RData")
save.image(file.path(file_paths$L1,rdata_file_name ))
```


## assign notes to those high confidence matches

Review Number of fixed names so far, out of all unmatched gbif
```{r}
#| echo: false
 paste(
  nrow(high_confidence_matches),
  "out of",
  nrow(unresolved.gbif)
 )

```
*previous results*

257 out of 326; May 29, 2025: 244



### Names Update  high-confidence matches, 
but only update those names that haven't already been dispensated and have a note

```{r}
#| echo: false

# update by Row number. Not very R-like but works

# get the row numbers of the names list that we want to update with matches
rows_high_confidence_match <- which(int.raw.names$scientific_name.raw %in%high_confidence_matches$scientific_name.raw)
# get the row numbers of names list already updated -> this process will not overwrite existing notes
rows_with_non_empty_notes <- which(!is.na(int.raw.names$edit_notes))

rows_to_update <- rows_high_confidence_match[!rows_high_confidence_match  %in% rows_with_non_empty_notes ]
print(paste("updating", length(rows_to_update), "rows"))
      
for(r in rows_to_update){
  # find the fuzzy matched name to use for new edit
  # matching the same raw name in the  high confidence list
  
  
  current_scientific_name.raw <- int.raw.names[r,]$scientific_name.raw
  
  high_confidence_match <- high_confidence_matches[
      high_confidence_matches$scientific_name.raw == int.raw.names[r,]$scientific_name.raw &
      high_confidence_matches$common_name.raw == int.raw.names[r,]$common_name.raw, ]
  
  if(nrow(high_confidence_match)>1) {
    # do we have redundant matches?  if so print those and skip
    print("duplicate matches")
    print(high_confidence_match)
    next # skip this one keep going
  }
  
  # extract values and update list
  int.raw.names[r,]$scientific_name.edit <- high_confidence_match$closest_scientific_name_match
  
  scientific_name_match_score <- as.character(high_confidence_match$scientific_name_match_score)
  
  int.raw.names[r,]$edit_notes <- paste('KEEP RAW: high confidence fuzzy match with Clements checklist score', scientific_name_match_score )

  
}

```

remaining unresolved after high-conf matches:

```{r}
#| echo: false
nrow(unresolved_species(int.raw.names))
```      

Unique scientific names in unresolved list: 

```{r}
length(unique(unresolved_species(int.raw.names)$scientific_name.raw))
```



--------------------------------------------------------------------------------
## Post-match manual name updates

Set matches based on review of fuzzy match to checklist

After reviewing those raw entries not exactly matched by GBIF, and assigned a
fuzzy matche value to the checklist, manually assign the `Scientific_name.edit` 
nad a note 

The following is a the template of how to call the function defined to set the 
species and the notes

*this may not seem like less typing that just assigning but by centralizing the 
procedure for updating records allows code improvements to be made in one place*

---

CHANGE TO CLOSEST MATCH: checklist says Corvus brachyrhynchos caurinus

there is a case to keep Corvus caurinus as a species...

https://bcbirds.bcfo.ca/wp-content/uploads/2021/11/butler.pdf

 "Corvus caurinus"
```{r}
int.raw.names[int.raw.names$scientific_name.raw =="Corvus brachyrhynchos caurinus",]
print(interaction_count_by_species(int.raw, "Corvus caurinus"))
checklist[checklist$scientific_name=="Corvus caurinus",]

```

  
```{r}
int.raw.names <- add_name_edits(int.raw.names,
    scientific_name.raw = "Corvus caurinus",
    edit_notes = "CHANGE TO CLOSEST MATCH: checklist Northwestern Crow Corvus brachyrhynchos caurinus checklist match  0.900468284",
    scientific_name.edit = "Corvus brachyrhynchos caurinus"
  )

```

Previously also corrected *Larus spp.*, but this is no longer in db

```{r}
int.raw.names[int.raw.names$scientific_name.raw =="Larus brachyrhynchos caurinus",]
print(interaction_count_by_species(int.raw, "Larus brachyrhynchos caurinus"))
```

CHANGE TO CLOSEST MATCH: checklist says Campylorhynchus brunneicapillus

```{r}
int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Campylorhynchos brunneicapillus",
                 scientific_name.edit = "Campylorhynchus brunneicapillus",
                 edit_notes = "CHANGE TO CLOSEST MATCH: checklist Cactus Wren Campylorhynchus brunneicapillus 0.900716846"
  )

```


```{r}
int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Cathartus aura",
                 scientific_name.edit = "Cathartes aura",
                 edit_notes = "CHANGE TO CLOSEST MATCH: checklist Cathartus aura Turkey Vulture  Cathartes aura  0.901098901"
  )

```


 Moticilla alba lugens = White Wagtail (Black-Backed), typo fix 

```{r}
int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Moticilla alba lugens",
                 scientific_name.edit = "Motacilla alba lugens",
                 edit_notes = "CHANGE TO CLOSEST MATCH:  checklist Moticilla alba lugens White Wagtail (Black-Backed) ->   Motacilla alba lugens   0.901587302"
  )

```

Moticilla alba ocularis = White Wagtail (ocularis), misspelled genus

```{r}
filter(checklist, scientific_name == "Motacilla alba ocularis")

int.raw.names <- add_name_edits(int.raw.names, 
                 scientific_name.raw = "Moticilla alba ocularis",
                 edit_notes = "CHANGE TO CLOSEST MATCH: checklist Motacilla alba ocularis White Wagtail (Ocularis), Pied Wagtail",
                 scientific_name.edit = "Motacilla alba ocularis",
                 common_name.edit = "White Wagtail (ocularis)"
  )

```



---

??? look for this common name and assign

KEEP RAW and change to species later when lumping subspecies
 checklist: Parkesia noveboracensis;
 int.raw and unresolved.gbif: common_name = hybrid Barnacle x Bar-headed Goose
 BOW says the hybrid exists but is rare



---


### This was code left over from  before removing hybrids

??? SAVE HYBRIDS OR REMOVE THEM?

```         
1 Branta leucopsis x anser indicus Branta leucopsis x canadensis       0.905
```

```
dplyr::filter(int.raw, species1_scientific %in% c("Branta leucopsis x"))
# NO HYBRIDS IN CLEANED DATA NOW
dplyr::filter(int.raw, species1_scientific %in% c("Branta leucopsis x Anser indicus"))
dplyr::filter(int.raw, species2_scientific %in% c("Branta leucopsis x Anser indicus"))
# dplyr::filter(unresolved.gbif, scientific_name.edit %in% c("Branta leucopsis x anser indicus"))
# dplyr::filter(unresolved.gbif, scientific_name.edit %in% c("Branta leucopsis x anser indicus"))
# fixed_names1$scientific_name[fixed_names1$scientific_name.edit == "Branta leucopsis x anser indicus"] <- "Branta leucopsis x Anser indicus"
```


```{r}
int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Cuculus canorus telephonus",
                 scientific_name.edit = "Cuculus canorus telephonus",
                 edit_notes = "KEEP RAW: Cuculus canorus common_name = Common Cuckoo
BOW says 'sometimes separated subspecifically as telephonus on basis of size (smaller than subtelephonus) and pale plumage (like subtelephonus), but birds in this area are not constant in these characters and overlap with other races occurs'"
  )

```


Reconcile "Parkesia noveboracensis limnaeus"

number of interaction records with this species?

```{r}
print(interaction_count_by_species(int.raw,"Parkesia noveboracensis limnaeus"))
```


```{r}

int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Parkesia noveboracensis limnaeus",
                 scientific_name.edit = "Parkesia noveboracensis",
                 edit_notes = "CHANGE TO CLOSEST MATCH: BOW says No subspecies, following Eaton (1957a) and Molina et al. (2000). Hence, P. n. notabilis (Ridgway, 1880), P. n. limnaeus (McCabe and Miller, 1933), and P. n. uliginosus (Burleigh and Peters, 1948) are junior synonyms of P. noveboracensis (Gmelin, 1788).  0.906"
  )

```


```{r}

print(interaction_count_by_species(int.raw,"Zosterops lateralis gouldi"))

int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Zosterops lateralis gouldi",
                 scientific_name.edit = "Zosterops lateralis",
                 edit_notes = "CHANGE TO CLOSEST MATCH bc unresolved: BOW says: 
                 In Australia, birds previously known as race gouldi, but chloronotus has priority and not preoccupied by 'chloronothos'."
  )

```

CHANGE TO CLOSEST MATCH bc unclear: BOW: Mainland races tend to intergrade;intermediates between erythronotus and tricolor sometimes referred to as
'nigriceps', a name better applied to a 'swarm of intergrades' in NC India Lanius schach erythronotus/tricolor Lanius schach erythronotus       0.914

```{r}
interaction_count_by_match(int.raw,'erythronotus')
interaction_count_by_species(int.raw, "Lanius schach erythronotus/tricolor")
```

```{r}
int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Lanius schach erythronotus/tricolor",
                 scientific_name.edit = "Lanius schach erythronotus",
                 edit_notes = "CHANGE TO CLOSEST MATCH bc unclear: BOW: Mainland races tend to intergrade;intermediates between erythronotus and tricolor sometimes referred to as 'nigriceps', a name better applied to a 'swarm of intergrades' in NC India Lanius schach erythronotus/tricolor Lanius schach erythronotus 0.914"
  )

```



```{r}
int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Aphelocoma woodhouseii suttoni",
                 scientific_name.edit = "Aphelocoma woodhouseii suttoni",
                 edit_notes = "KEEP RAW for now because it is a subspecies: BOW: A. w. suttoni Phillips, 1965. "
  )
```

  
KEEP RAW for now because it is a subspecies: BOW: A. w. suttoni Phillips, 1965.

Includes A. w. mesolega Oberholser, 1974 (see Browning 1990). Breeds in
foothills of Rocky Mountains from northern and eastern Utah (east of the Great
Salt Lake Basin; Behle 1985) and southern Wyoming south through
northeasternmost Arizona, northern Arizona, Colorado, central New Mexico, and
westernmost Oklahoma to northern Chihuahua and western Texas (Pitelka 1945a,
Pitelka 1951d) [type locality = Pueblo, Colorado]; some individuals wander in
winter to lowlands south of the breeding range, such as the Colorado Desert
(Phillips et al. 1964a, Patten et al. 2003) and Texas Panhandle (Seyffert1985).

```
1 Aphelocoma woodhouseii suttoni   Aphelocoma woodhouseii cyanotis       0.916
```

#### Wrap-up manual fixes

Unique scientific names in unresolved list and manu: 

```{r}
length(unique(unresolved_species(int.raw.names)$scientific_name.raw))
```



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Fuzzy Match on Common names

after applying high-confidence matches, try matching on common names

```{r}
# create list of names to match from unresolved rows
name_matches<- unresolved_species(int.raw.names)
# add new columns
name_matches$closest_name_match <- NA
name_matches$name_match_score <- NA
name_matches$scientific_name.checklist <- NA

checklist_common_names<- filter(checklist,category == "species" )$common_name

# fill them in one row at a time
for(r in 1:nrow(name_matches)) {
  # optional, print the name we are on to gauge progress
  # print(scientific_name_matches[r,"scientific_name.edit"])
  
  raw_common_name<-name_matches[r,"common_name.raw"] 
  fuzzy_match <- find_closest_match_with_score(raw_common_name, checklist_common_names)
  

  
  # find the associated sci name, but only look at species records 
  # (some groups have the same common name for the whole genus)
  scientific_name_lookup <- as.character(filter(checklist, 
                                    common_name == fuzzy_match$match & category == "species") %>%   
                          select(scientific_name))
  if(length(scientific_name_lookup) == 0) warning(paste(" no scientific name in checklist for ",fuzzy_match$match))
  else {
    name_matches[r,]$closest_name_match <- fuzzy_match$match
    name_matches[r,]$name_match_score <- fuzzy_match$score
    name_matches[r,]$scientific_name.checklist <- scientific_name_lookup 
  }
}
```



```{r}
name_matches %>% arrange(desc(name_match_score))
```

#### Example Matches to set threshold

Raw  Checklist Match ( match value)

- *Northern Jancan* matches *Northern Jacana* 0.9458333	=> correct
- *Black-Winged Babbler*	matches *Black-chinned Babbler*	0.9190476 => incorrect 

Conclusion there is no obvious threshold for match scores 0.9 = < s < 1.0, so 
set threshold to 1.0

```{r}
common_name_match_threshold <- 1.0
```

Update name edits using common name matches

```{r}
#| echo: false

high_confidence_matches <- filter(name_matches, name_match_score >= common_name_match_threshold)

# update by Row number. Not very R-like but works

# get the row numbers of the names list that we want to update with matches
rows_high_confidence_match <- which(int.raw.names$common_name.raw %in% high_confidence_matches$common_name.raw)
# get the row numbers of names list already updated -> this process will not overwrite existing notes
rows_with_non_empty_notes <- which(!is.na(int.raw.names$edit_notes))

rows_to_update <- rows_high_confidence_match[!rows_high_confidence_match  %in% rows_with_non_empty_notes ]

print(paste("updating", length(rows_to_update), "rows"))
      
for(r in rows_to_update){
  # find the fuzzy matched name to use for new edit
  # matching the same raw name in the  high confidence list
  
  current_common_name.raw <- int.raw.names[r,]$common_name.raw
  
  high_confidence_match <- high_confidence_matches[
      high_confidence_matches$scientific_name.raw == int.raw.names[r,]$scientific_name.raw &
      high_confidence_matches$common_name.raw == int.raw.names[r,]$common_name.raw, ]
  
  if(nrow(high_confidence_match)>1) {
    # do we have redundant matches?  if so print those and skip
    print("duplicate matches")
    print(high_confidence_match)
    next # skip this one keep going
  }
  
  # update sci name edit to matching checklist sciname
  int.raw.names[r,]$scientific_name.edit <- high_confidence_match$scientific_name.checklist
  
  # update notes 
  int.raw.names[r,]$edit_notes <- paste('KEEP RAW: high confidence fuzzy match with Clements checklist common name checklist ',
       as.character(high_confidence_match$name_match_score ))

  
}


```


### Manual edits after common name match 

Jancana spinosa matched Northern Jacana, discovering the typo

```{r}

int.raw.names <- add_name_edits(int.raw.names,
            "Jancana spinosa",
            "Typo edit:Jancana spinosa should be  Jacana spinosa Northern Jacana",
            "Jacana spinosa",
            "Northern Jacana")

```
Remaining Unresolved Species:

```{r}
nrow(unresolved_species(int.raw.names))
```


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Scientific Name Changes: Low Confidence Matches on scientific name

Extract scientific name matches with lower confidence (match_score <= 0.90) 
for those remaining species that didn't match for further 
checking

```{r}

low_confidence_matches <- scientific_name_matches %>%
  filter(
    (scientific_name_match_score < 0.9 & !is.na(scientific_name_match_score)) 
  ) %>% 
  filter( # remove unid species from matches
    !grepl(" sp\\.$", closest_scientific_name_match)
  ) %>% 
  filter(
    scientific_name.raw %in% unresolved_species(int.raw.names)$scientific_name.raw
  ) 

  # couldn't get Mutate to work, so here is a loop to add in the common name where it's found
  low_confidence_matches$common_name.checklist <- NA
  for(r in 1:nrow(low_confidence_matches)){
    common_names <- filter(checklist,scientific_name == low_confidence_matches[r,"closest_scientific_name_match"] & category == "species")$common_name
    if(length(common_names)==1) low_confidence_matches[r,"common_name.checklist"]<- common_names[1]
  }


length(unique(low_confidence_matches$scientific_name.raw))
```

previously 69 out of 326 - checks out OK; May 29, 2025: 65


Check Low Confidence Matches , based on scientific_name:
Define range for printing in increments of 0.005


Examine low confidence matches

```{r}

View(low_confidence_matches) #  %>% select(-c(scientific_name.edit, common_name.edit, edit_notes))
```


```{r}
# For most of the names, assign them the closest match, then edit the few above
# noted "KEEP RAW".
## fixed_names2<-low_confidence_matches
# Test: Accipiter cooperi is misspelled - it is present here?

dplyr::filter(low_confidence_matches, scientific_name.raw %in% c("Accipiter cooperi"))
# # A tibble: 1 Ã— 6
# scientific_name.raw common_name.raw scientific_name.edit common_name.edit closest_scientific_name_match
# <chr>             <chr>           <chr>              <chr>            <chr>                      
#   1 Accipiter cooperi Cooper's Hawk   Accipiter cooperi  Cooper's Hawk    Accipiter poliogaster      
# scientific_name_match_score
# <dbl>
#   1                     0.849

```


Scroll through these Low Confidence Matches in order from highest to lowest

Assigning closest low-confidence match with update notes,
and will be updated if necessary below

??? PLZ I believe now that we are Matching common names, the 10 remaining should
be matched manually, disabling this next part 

```{r}

# disabled, to be deleted 

# # get the matches in the int.raw.names, which will then be in the same order 
# # order as the df with our matches
# rows_to_update <- match(low_confidence_matches$scientific_name.raw, int.raw.names$scientific_name.raw)
# # save a copy
# int.raw.names.copy_pre_low_confidence <- int.raw.names
# 
# int.raw.names[rows_to_update, ]$scientific_name.edit <- low_confidence_matches$closest_scientific_name_match
# int.raw.names[rows_to_update, ]$edit_notes <- paste("Replace w fuzzy match low confidence to checklist", low_confidence_matches$scientific_name_match_score)
# # view the outcome
# tibble(int.raw.names[rows_to_update,])

```





--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

### Manual fixes after exploring the checklist 

```{r}
scientific_name.to_fix = "Parkesia noveboracensis notabilis"
filter(int.raw.names,scientific_name.raw==scientific_name.to_fix) 

```

```{r}
int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Parkesia noveboracensis notabilis",
                 scientific_name.edit = "Parkesia noveboracensis",
                 edit_notes = "ACCEPT CHANGE TO CLOSEST MATCH because BOW states 'No subspecies, following Eaton (1957a) and Molina et al. (2000).'. Common name in int.raw is Northern Waterthrush. 1 Parkesia noveboracensis notabilis Parkesia noveboracensis       0.899"
  )

```


```{r}

int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Columbina livia",
                 scientific_name.edit = "Columba livia",
                 edit_notes = "KEEP RAW but edit it. This is 'Rock Dove' which is also known as Rock Pigeon. Should be Columba livia Columbina livia Columbina inca 0.886"
  )

```

**Unresolved by Matching: Argya affinis somervillei**

```{r}
intxns_by_species(int.raw,"Argya affinis somervillei")
```
```{r}
int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Argya affinis somervillei",
                 scientific_name.edit = "Argya striata somervillei",
                 edit_notes = "KEEP RAW and edit: BOW and checklist: 'Black-winged Babbler' is most likely Jungle Babbler (Black-winged) Argya striata somervillei match  Argya affinis somervillei  Argya affinis  0.84  "
  )


```


#######################

??? PLZ could use help determining this one, the note doesn't match the problem

 - entry is an unid, could be one or the ther
 - the note talks about subspecies but this is not the case here
 - decision needs to be made to match to checklist for this ambiguous id

```{r}
scientific_name.to_fix <- "Setophaga striata / tigrina"
scientific_name_matches %>%filter(scientific_name.raw == scientific_name.to_fix)

```

This is an unid that could be one or the other.. closest match is the species Setophaga striata

```{r}

filter(checklist, scientific_name == "Setophaga tigrina")
```

```{r}
# disabled this one, needs edit
# int.raw.names <- add_name_edits(int.raw.names, 
#       scientific_name.raw = "Setophaga striata / tigrina",
#       edit_notes = "ACCEPT CHANGE TO CLOSEST MATCH: BOW states no subspecies: No subspecies, following Parkes (1954), who could not diagnose a difference between northeastern
# breeders and those farther west, which were named S. s. lurida (Burleigh and Peters, 1948).",
#       scientific_name.edit = "",
#       )
# 
# 
# 
# # ACCEPT CHANGE TO CLOSEST MATCH: BOW states no subspecies: "No subspecies, following
# # Parkes (1954), who could not diagnose a difference between northeastern
# # breeders and those farther west, which were named S. s. lurida (Burleigh and
# # Peters, 1948)."
# # 1 Setophaga striata / tigrina Setophaga striata       0.877
# int.raw[which(int.raw$species1_scientific == "Setophaga striata / tigrina"), ]
# int.raw[which(int.raw$species2_scientific == "Setophaga striata / tigrina"), ]
```

American Pipit - this seems to be fixed in raw data
```{r}

print(interaction_count_by_match(int.raw, "Anthus americanus"))
print(interaction_count_by_match_common(int.raw, "American Pipit"))
```

```{r}
# disabled until confirmation to be deleted
# checklist[which(checklist$common_name == "American Pipit"), ]
# 
# int.raw.names <- int.raw.names %>% 
#   add_name_edits(scientific_name.raw = "Anthus americanus",
#                  scientific_name.edit = "Anthus rubescens",
#                  edit_notes = "KEEP RAW but edit it. BOW and checklist: Polytypic American Pipit Anthus rubescens is split into monotypic Siberian Pipit Anthus japonicus and polytypic American Pipit Anthus rubescens (with subspecies pacificus, rubescens, and alticola). int.raw interaction appears to be for North american species and observation (Parasitic Jaeger). Interaction is with 'American Pipit'; checklist states 'Anthus rubescens' 
# Anthus americanus     Anthus cervinus  0.871"
#   )

```


```{r}
filter(int.raw.names, scientific_name.raw == "Anas affinis")
```

```{r}
# this edit disabled, fixed by common name match

# int.raw.names <- int.raw.names %>% 
#   add_name_edits(scientific_name.raw = "Anas affinis",
#                  scientific_name.edit = "Aythya affinis",
#                  edit_notes = "KEEP RAW and edit: checklist: Lesser Scaup =	Aythya affinis Anas affinis   Argya affinis       Lesser Scaup  Lesser Scaup   0.868"
#   )


```


Hairy Woodpecter

```{r}
filter(int.raw.names, scientific_name.raw == "Leucophaeus villosus")
```

```{r}
# disabled here, fixed during common name matching

# int.raw.names <- int.raw.names %>% 
#   add_name_edits(scientific_name.raw = "Leucophaeus villosus",
#                  scientific_name.edit = "Dryobates villosus",
#                  edit_notes = "KEEP RAW and edit: Common name in int.raw is Hairy Woodpecker, so genus is off. Dryobates villosus Leucophaeus villosus                   Leucophaeus modestus 0.867"
#   )

```


Chrysococcyx meyerii: White-Eared Bronze-Cuckoo

```{r}
filter(int.raw.names, scientific_name.raw == "Chrysococcyx meyerii")  %>% select(scientific_name.edit, common_name.edit, edit_notes)
```

```{r}
# disabled since fixed by common name match
# checklist[which(checklist$common_name == "White-Eared Bronze-Cuckoo"), ]
# int.raw.names <- int.raw.names %>% 
#   add_name_edits(scientific_name.raw = "Chrysococcyx meyerii",
#                  scientific_name.edit = "Chalcites meyerii",
#                  edit_notes = "KEEP RAW and edit: checklist: White-Eared Bronze-Cuckoo = Chalcites meyerii"
#   )
 

```



Double-Crested Cormorant: checklist species change


```{r}
print(interaction_count_by_species(int.raw, "Phalacrocorax auritus"))
```
```{r}
filter(int.raw.names,scientific_name.raw == "Phalacrocorax auritus")
```

```{r}
checklist_common_name ="Double-crested Cormorant"
checklist[which(checklist$common_name == checklist_common_name), ]

```


Update scientific name Phalacrocorax auritus / Double-Crested Cormorant 
based on discovery in checklist and matching common name

```{r}

int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Phalacrocorax auritus",
                 scientific_name.edit = "Nannopterum auritum",
                 edit_notes = "KEEP RAW and edit: checklist: Double-Crested Cormorant = Nannopterum auritum Phalacrocorax saltatrix")

```



### Example, reviewing a change already made by common name match



```{r}

checklist[which(checklist$common_name == "Black-necked Stilt"), ]
```

```{r}
filter(int.raw.names, scientific_name.edit == "Himantopus mexicanus")
```

Pomarine Jaeger = Stercorarius pomarinus 

```{r}

interaction_count_by_species(int.raw,"Stercorarius stercorarius")
checklist[which(checklist$common_name == "Pomarine Jaeger"), ]

int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Stercorarius stercorarius",
                 scientific_name.edit = "Stercorarius pomarinus",
                 edit_notes = "KEEP RAW but edit: checklist: Pomarine Jaeger = Stercorarius pomarinus Also raw has space at end 5 Stercorarius stercorarius Stercorarius parasiticus    Pomarine Jaeger     Pomarine Jaeger  0.857
"

)

```



White Wagtail

```{r}

int.raw.names <- add_name_edits( int.raw.names, 
        scientific_name.raw = "Moticilla alba",
        scientific_name.edit = "Motacilla citreola",
        edit_notes = "KEEP RAW, Common name in int.raw is the White Wagtail. Moticilla alba            Motacilla citreola             0.858"
  )

```


*"Speckled Teal"*
```{r}
scientific_name.to_fix <- "Anas flavirostris / anas andium"
filter(int.raw.names, scientific_name.raw == scientific_name.to_fix)
```
if zero rows, not in the db - keep?  

```{r}
scientific_name.checklist = "Anas andium/flavirostris"
filter(checklist, scientific_name == scientific_name.checklist) %>% select(scientific_name, common_name)
```



```{r}

int.raw.names <- add_name_edits( int.raw.names, 
     scientific_name.raw = "Anas flavirostris / anas andium" ,
     scientific_name.edit = "Anas andium/flavirostris",
     edit_notes = "KEEP RAW and edit: According to BOW there is no Anas flavirostris / anas andium. Common name in int.raw is Speckled Teal but checklist is Andean/Yellow-billed Teal."
  )

```


**House Finch (Haemorhous mexicanus)**

Fixed during common name match, can delete

```{r}
scientific_name.to_fix <-  "Hirundo mexicanus"
filter(int.raw.names, scientific_name.raw == scientific_name.to_fix)
```


```{r}

int.raw.names <- 
  add_name_edits(int.raw.names, 
                 scientific_name.raw =  "Hirundo mexicanus",
                 scientific_name.edit = "Haemorhous mexicanus",
                 edit_notes = "KEEP RAW and edit. Common name in int.raw is House Finch (Haemorhous mexicanus)."
    ) 

```


################
??? PLZ

### Hawks

```{r}
  int.raw.names <- int.raw.names %>%
  add_name_edits( scientific_name.raw = "Accipiter cooperi",
                  edit_notes = "KEEP RAW and edit. Checklist shows genus moved to Astur. Also species is cooperii.",
                 scientific_name.edit = "Astur cooperii"
  ) %>%
  add_name_edits(scientific_name.raw = "Accipiter sp.",
                 scientific_name.edit = "Aerospiza/Tachyspiza/Accipiter/Astur sp.",
                 edit_notes = "Hawk changes "
  ) 

```

Accipiter atricapillus IF American Goshawk, then we can change it.  

All goshawk rows: 
```{r}
filter(int.raw.names, scientific_name.raw ==  "Accipiter atricapillus")
```

yes - no European Goshawk in our names 

```{r}
  int.raw.names<- add_name_edits(int.raw.names, 
                 scientific_name.raw = "Accipiter atricapillus", #  Note: need to ensure that is not European Goshawk.  
                 scientific_name.edit = "Astur atricapillus",
                 edit_notes = "Listed as American Goshawk; KEEP RAW and edit to Astur"
  )

```




```{r}

int.raw.names <- int.raw.names %>% 
  add_name_edits(scientific_name.raw = "Accipiter getilis",
                 scientific_name.edit = "Astur atricapillus",
                 edit_notes = "KEEP RAW and edit. Checklist shows genus moved to Astur atricapillus.  Accipiter getilis Accipiter poliogaster       0.839"
  )


```



Thyrothorus rufalbus - fixed by common name match, can delete

```{r}

filter(int.raw.names, scientific_name.raw == "Thyrothorus rufalbus")

```


```{r}
# disabled - fixed by common name
# int.raw.names <- int.raw.names %>% 
#   add_name_edits(scientific_name.raw = "Thyrothorus rufalbus",
#                  scientific_name.edit = "Thryophilus rufalbus",
#                  edit_notes = "CHANGE TO CLOSEST MATCH: original common name: Rufous-and-white Wren; checklist confirms the suggested scientific_name change. Thyrothorus rufalbus Thryophilus rufalbus       0.831 "
#   )
# 


```


"Chrysococcyx meyerii" fixed by common name match, can delete

```{r}
# disable, already martched by common name
# 
# int.raw.names <- add_name_edits(int.raw.names,
#                   scientific_name.raw ="Chrysococcyx meyerii",
#                   scientific_name.edit = "Chalcites meyerii",
#                   edit_notes = 'Common name in int.raw = White-eared Bronze-Cuckoo. Checklist states: Move from Chrysococcyx into Chalcites to become Chalcites meyerii.'
# )
 

```


???
##### PLZ start here ##### 


### FIX LIST Edits to apply to int.raw.names

Two ways to add an edit/adjustment to the list:

1. call the `add_name_edits` function with arguments including the data frame
   used to collect these edits (`int.raw.names`, see above)

2. add to this list below with the arguments in the following order, which are 
   added one by one calling that `add_name_edits` function
  
   - original scientific_name (raw) as appears in interaction file, 
   - editing notes, dispensation or why an edit is needed or d, 
   - (optional) scientific_name.edit IF the name is changed
   - (optional) common_name.edit if the name was changed 


```{r}

# this list is typed in this way to enable easy cutting/pasting from original 
# code and for future readability, must be in order raw, notes, optional sciname edit, optional common name edit
raw_names_edits <-list(c(
"Chrysococcyx meyerii",
"Common name in int.raw = White-eared Bronze-Cuckoo. Checklist states: Move from Chrysococcyx into Chalcites to become Chalcites meyerii.",
"Chalcites meyerii"
),c(
"Accipter atricapillus",
"KEEP RAW and edit. This is the Eurasian Goshawk based on the location of the interaction (Svalbard): was Accipter atricapillus and is now Astur gentilis",
"Astur gentilis"
), c(
"Panyptila saxatilis",
"",
"Aeronautes saxatalis"
),c(
"Hirundo pyrrhonta",
"KEEP RAW and edit: int.raw common name is Cliff Swallow, Checklist and BOW: changed to Petrochelidon pyrrhonota.",
"Petrochelidon pyrrhonota"
),c(
"Pyrrhuloxia sinuata",
"KEEP RAW and edit: Pyrrhuloxia BOW and checklist is Cardinalis sinuatus",
"Cardinalis sinuatus"
),c(
"Dendroica petechia (erithachordies)",
"KEEP RAW and edit: Yellow Warbler (Mangrove) BOW and checklist: Setophaga petechia [erithachorides Group]",
"Setophaga petechia [erithachorides Group]"
),c(
"Dendroica pinus",
"KEEP RAW and edit: Pine Warbler BOW and checklist: Setophaga pinus",
"Setophaga pinus"
),c(
"Accipiter cirrhocephalus",
"KEEP RAW and edit: Collared Sparrowhawk BOW and checklist: Genus changed to Tachyspiza cirrocephala",
"Tachyspiza cirrocephala"
),c(
"Lophortyx californicus",
"KEEP RAW and edit: California Quail BOW and checklist: California Quail; Genus changed to Callipepla californica",
"Callipepla californica"
),c(
"Oceanodroma leucorrhoa",
"KEEP RAW and edit; checklist: Leach's Storm-Petrel = Hydrobates leucorhous Oceanodroma leucorrhoa Paraclaravis mondetoura ochoterena Leach's Storm-Petrel Leach's Storm-Petrel ",
"Hydrobates leucorhous"
),c(
"Roseate spoonbill",
"KEEP RAW and edit int.raw; this entry has multiple columns off for scientific and common BOW and checklist: scientific_name of Roseate Spoonbill = Platalea ajaja",
"Platalea ajaja"
)
 
# end of list of edits
)
```









--------------------------------------------------------------------------------

## Unid sp.  fixes

??? PLZ 

Open the Unid sp. (Genu-only) to work on:

How many unique Unid sp?
 
```{r}
int.raw.names.unid <- filter(int.raw.names, grepl(" sp\\.$", scientific_name.raw))
length(unique(int.raw.names.unid$scientific_name.edit))

# optional, in Rstudio, open the list in a new tab
# View(int.raw.names.unid )

```

### TYPOS


```{r}

int.raw.names <- add_name_edits(int.raw.names, 
    scientific_name.raw = "Duck sp.",
                         edit_notes = "KEEP RAW and edit Duck sp. = Anatidae sp.",
                         scientific_name.edit="Anatidae sp."
                         )

```


typo 'hawl' 

```{r}
interaction_records_by_match(int.raw, 'hawl')
```

??? PLZ this was from previous code, please fix as needed


```{r}

# ??? review 
int.raw.names <- int.raw.names %>% 
          add_name_edits(int.raw.names, 
                 scientific_name.raw = "unid. Accipiter hawl",
                 scientific_name.edit =  "Aerospiza/Tachyspiza/Accipiter/Astur sp.",
                 edit_notes = "typo, assign generic hawk group")
  

# previous code
# unid. Accipiter hawl
# fixed_names2$scientific_name[fixed_names2$scientific_name.edit == "unid. 2 hawl"] <- "Aerospiza/Tachyspiza/Accipiter/Astur sp."
# fixed_names2$scientific_name[fixed_names2$scientific_name.edit == "unid. Accipiter hawl"] <- "Aerospiza/Tachyspiza/Accipiter/Astur sp."


```




## Examine Name Corrections and Notes so far


Total number of name combinations in database:


```{r}
#| echo: false
#| output: true

print(nrow(int.raw.names))

```

number of full species without notes (dispensation/edits) :

```{r}
#| echo: false
#| output: true

print(nrow(unresolved_species(int.raw.names)))

```

number of all rows without notes (dispensation/edits) including UnID:

```{r}
#| echo: false
#| output: true

print( nrow( filter(int.raw.names, is.na(edit_notes))))

```


### checkpoint save
```{r}
#| echo: false
#| output: true

today_date_string <- format(Sys.Date(),"%Y-%m-%d")
rdata_file_name <- paste0("AvianInteractionData_L1_workspace", today_date_string, ".RData")
f <- file.path(file_paths$L1,rdata_file_name )
save.image(f)

print(paste("whole enviroment saved as ", f))


```



--------------------------------------------------------------------------------

## Join with Checklist and report 

Join the scientific name 'edits' with the current Clements checklist
to start matching for final species.  

This adds final columns 

- scientific_name.checklist
- common_name.checklist

which would ultimately but what is published. 

```{r}
#| echo: false

# Historical code, can be deleted but saved for now to compare
# note this code from previous version shows status of unresolved names
# perhaps from GBIF?  not sure about main checklist

# fixed.unresolved.gs<-rbind(fixed_names1,fixed_names2)
# fixed.unresolved.gs$scientific_name_match_score<-NULL
# length(unique(fixed.unresolved.gs$scientific_name.raw))
# # 326 OK; May 29, 2025: 309
# dim(fixed.unresolved.gs)
# # 339 fixed unresolved species names; May 29, 2025: 322
```


At this stage, scientific_name.checklist == scientific_name.edit where 
they match, leaving scientific_name.edit as GBIF entries that need updating

Call the join function from L1 functions script and view the results
```{r}
#| echo: false
#| output: true

# add a checklist column - this will be the sci name to publish

int.raw.names.checklist<- checklist_merge(int.raw.names, checklist)
View(int.raw.names.checklist)

```


How many rows are not in the checklist (sci/common combos):

```{r}
#| echo: false
#| output: true

filter(int.raw.names.checklist, is.na(scientific_name.checklist))  %>%
  nrow()
```



Rows to to match that full scientific names (not unids): 

```{r}
#| echo: false
#| output: true

filter(int.raw.names.checklist, is.na(scientific_name.checklist)) %>%
  filter(!grepl(" sp\\.$", scientific_name.raw)) %>%
  nrow()

```


Number of scientific names (not unids, ignoring common names) that are GBIF-only:

```{r}
#| echo: false
#| output: true

filter(int.raw.names.checklist, is.na(scientific_name.checklist)) %>%
  filter(!grepl(" sp\\.$", scientific_name.raw)) %>% 
    select(scientific_name.edit) %>% unique() %>% nrow()
    

```

**Save our lists so far as CSV with the current date**

```{r}
#| echo: false
#| output: true

today_date_string <- format(Sys.Date(),"%Y-%m-%d")
taxonomic_edits_file_name =  paste0("AvianInteractionData_L1_taxonomic_updates_", today_date_string, ".csv")

f = file.path(file_paths$L1, taxonomic_edits_file_name)
write.csv(int.raw.names.checklist, file = row.names = FALSE)
print(paste("saved file", f))
```


## Final Taxonomic Edits


### Using common-name fuzzy match 

Of the unique scientific names (not unids) above that are GBIF-only, attempt 
to match on common name to

1) get the accepted common name from Taxadb for matching Scientific name
2) match this common name with Clements 


```{r}


```


### Remaining unmatched: apply subset/curated list 

For the remaining scientific names that we have not matched yet, use
the current  the Canada+CONUS list which has gbif to checklist mapping
but is not all species. 


## Manual Fixes to Final Checklist


This takes the GBIF fixes and applies the latest Clements taxonomy update

*TO-DO: Adopt these to the note assignment raw to edit**

**Workflow: **

Goal is to accumulate a list of fixes and notes

1. review existing edits below
   use a lookup function to see if an edit (raw -> edit, common name) is still needed
   TO-DO : write this lookup/diagnostic function or block of code here!!

2. use sleuthing to  


Our current workflow use `int.raw.names`  and resolves in this order: 

1. scientific_name.raw : what's in entered data
2. scientific_name.edit : corrected to match either correct GBIF or Clements checklist
3. scientific_name.checklist : final resolved name from GBIF to Clements checklist


## Manual fixes 

*Note about historical code: delete this note when complete*

********FIXING INCORRECT GBIF RESOLVED: NOW HERE, EARLIER IN WORKFLOW******

Fixes from previous work to be confirmed and converted to our current workflow

Previous code copies the confirmed checklist taxon into a column 
`resolved.gbif$scientific_name` which we are no longer using (see above)

*Many of these changes have already been made above. *
edit these here by changing the before merging in.


> Check recent changes in resolved.gbif (where GBIF may be incorrect):
> See if the resolved.gbif contain Accipiter gentilis or Accipiter atricapillus
> as scientific_name ... Yes, so need to update these

**Northern Goshawk**

*THIS IS FIXED ABOVE*

check the common name if Northern Goshawk -> American Goshawk and Astur atricapillus
BUT if it's only Goshawk, check raw data to see if it's Europe the keep scientific name
but if it's N. america, change as above and rename American Goshawk 

```
resolved.gbif[which(resolved.gbif$scientific_name.edit == "Accipiter gentilis"), ]
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Accipiter gentilis"] <- "Astur atricapillus"
resolved.gbif$scientific_name[resolved.gbif$scientific_name.raw == "Astur atricapillus"] <- "Astur atricapillus"
```

```{r}
rawsp<- "Canachites canadensis"
checklistsp <- "Canachites canadensis"


```


Spruce Grouse: raw is Canachites
canadensis, Dendragapus canadensis, Falcipennis canadensis - in fact it should
be Canachites canadensis (GBIF is incorrect) Fix
```
resolved.gbif[which(resolved.gbif$common_name == "Spruce Grouse"), ]
splist2024[which(splist2024$bbs_common_name == "Spruce Grouse"), ]
resolved.gbif$scientific_name[resolved.gbif$common_name == "Spruce Grouse"] <- "Canachites canadensis"
```

```
# American Three-toed Woodpecker Picoides tridactylus - raw/edit is Picoides dorsalis
# Confirmed it is North American species, not European for this interaction.
splist2024[which(splist2024$bbs_common_name == "American Three-toed Woodpecker"), ]
resolved.gbif[which(resolved.gbif$common_name == "American Three-Toed Woodpecker"), ]
resolved.gbif$scientific_name[resolved.gbif$common_name == "American Three-Toed Woodpecker"] <- "Picoides dorsalis"

# Order below from: Sort by sp1sci.replaced, species1_scientific,	sp2sci.replaced, species2_scientific

# Clark's Grebe Aechmophorus clarkii transitionalis 
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Spilopelia chinensis"] <- "Aechmophorus clarkii transitionalis"

# # BBS does not contain these subspecies; Saltmarsh Sparrows but subspecies interactions only hybrid
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Ammospiza caudacuta caudacuta"] <- "Ammospiza caudacuta"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Ammospiza caudacuta diversa"] <- "Ammospiza caudacuta"

# # Seaside Sparrow & Nelson's Sparrow main species interactions; subspecies rare
# # Seaside Sparrow (Gulf of Mexico)	Nelson's Sparrow	Ammospiza maritima fisheri	Ammospiza nelsoni
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Ammospiza maritima fisheri"] <- "Ammospiza maritima"
# # Seaside Sparrow (Cape Sable)	Short-tailed Hawk	Ammospiza maritima mirabilis	Buteo brachyurus
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Ammospiza maritima mirabilis"] <- "Ammospiza maritima"
# # Nelson's Sparrow (Atlantic Coast)	Saltmarsh Sparrow	Ammospiza nelsoni subvirgata	Ammospiza caudacuta
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Ammospiza nelsoni subvirgata"] <- "Ammospiza nelsoni"
# # Nelson's Sparrow (Interior)	LeConte's Sparrow	Ammospiza nelsoni nelsoni	Ammospiza leconteii
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Ammospiza nelsoni nelsoni"] <- "Ammospiza nelsoni"
# # Nelson's Sparrow (Atlantic Coast)	Savannah Sparrow	Ammospiza nelsoni subvirgata	Passerculus sandwichensis
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Ammospiza nelsoni subvirgata"] <- "Ammospiza nelsoni"

# # Mountain Plover Charadrius montanus = Anarhynchus montanus
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Charadrius montanus"] <- "Anarhynchus montanus"

# Snowy Plover Charadrius nivosus = Anarhynchus nivosus	
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Charadrius nivosus"] <- "Anarhynchus nivosus"

#Sandhill Crane	Grus canadensis = Antigone canadensis
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Grus canadensis"] <- "Antigone canadensis"
# # No subspecies in BBS so combine; interactions all at species level also
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Antigone canadensis canadensis"] <- "Antigone canadensis"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Antigone canadensis rowani"] <- "Antigone canadensis"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Antigone canadensis tabida"] <- "Antigone canadensis"

# Muscovy Duck Cairina moschata domesticus = Cairina moschata
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Cairina moschata domesticus"] <- "Cairina moschata"

# Dunlin (pacifica)	Calidris alpina pacifica (not subspecies in BBS)

# Crested Caracara Caracara cheriway = Caracara plancus
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Caracara cheriway"] <- "Caracara plancus"

# Snow Goose Chen caerulescens = Anser caerulescens
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Chen caerulescens"] <- "Anser caerulescens"

# Turkey Vulture	Cathartes aura meridionalis	= Cathartes aura 
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Cathartes aura meridionalis"] <- "Cathartes aura"

# Wilson's Plover Charadrius wilsonia wilsonia = Anarhynchus wilsonia
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Charadrius wilsonia wilsonia"] <- "Anarhynchus wilsonia"

# Red-shafted Flicker	Colaptes auratus collaris	= Colaptes auratus cafer
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Colaptes auratus collaris"] <- "Colaptes auratus cafer"

# Gilded Flicker Colaptes chrysoides mearnsi = Colaptes chrysoides; interaction only hybrid
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Colaptes chrysoides mearnsi"] <- "Colaptes chrysoides"

# These have raw values but weren't updated? Odd
# Northwestern Crow	Corvus brachyrhynchos caurinus	
# Cooper's Hawk	Accipiter cooperi

# Western Flycatcher & Western Flycatcher (occidentalis/hellmayri group) Empidonax
# occidentalis = Empidonax difficilis occidentalis but hard to tell which one
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Empidonax occidentalis"] <- "Empidonax difficilis"

# No subspecies in CHECKLIST or BBS; unique interactions only hybrid
# # Arctic Loon	Gavia arctica arctica	Gavia arctica viridigularis
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Gavia arctica arctica"] <- "Gavia arctica"
# # Arctic Loon	Gavia arctica viridigularis
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Gavia arctica viridigularis"] <- "Gavia arctica"

# # Black-necked Stilt Himantopus mexicanus mexicanus = Himantopus mexicanus
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Himantopus mexicanus mexicanus"] <- "Himantopus mexicanus"

# # American Barn Swallow not subspecies in BBS but is in CHECKLIST
# # American Barn Swallow	Hirundo rustica erythrogaster - only 1 interaction
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Hirundo rustica erythrogaster"] <- "Hirundo rustica"

# No subspecies in BBS; combine but unique interactions are only hybrid
# #Hooded Oriole (sennettii)	Icterus cucullatus sennettii 
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Icterus cucullatus sennettii"] <- "Icterus cucullatus"
# #Hooded Oriole (cucullatus)	Icterus cucullatus cucullatus
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Icterus cucullatus cucullatus"] <- "Icterus cucullatus"

# # BBS no subspecies but interactions are only hybrid
# #Audubon's Oriole (Audubon's)	Icterus graduacauda audubonii	& Icterus graduacauda graduacauda = Icterus graduacauda
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Icterus graduacauda audubonii"] <- "Icterus graduacauda"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Icterus graduacauda graduacauda"] <- "Icterus graduacauda"

# # Juncos: many subspecies but most interactions at species level
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Junco hyemalis carolinensis"] <- "Junco hyemalis"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Junco hyemalis dorsalis"] <- "Junco hyemalis"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Junco hyemalis montanus"] <- "Junco hyemalis"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Junco hyemalis pinosus"] <- "Junco hyemalis"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Junco hyemalis pontilis"] <- "Junco hyemalis"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Junco hyemalis shufeldti"] <- "Junco hyemalis"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Junco hyemalis thurberi"] <- "Junco hyemalis"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Junco hyemalis caniceps"] <- "Junco hyemalis"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Junco hyemalis townsendi"] <- "Junco hyemalis"
# 
# # No subspecies in BBS but is in CHECKLIST as Gray-crowned Rosy-Finch (Gray-crowned)
# # Leucosticte tephrocotis [tephrocotis Group]
# # Sierra Nevada Gray-crowned Rosy-Finch	Leucosticte tephrocotis dawsoni
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Leucosticte tephrocotis dawsoni"] <- "Leucosticte tephrocotis"
# #Aleutian and Kodiak Island Gray-crowned Rosy-Finch	Leucosticte tephrocotis griseonucha
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Leucosticte tephrocotis griseonucha"] <- "Leucosticte tephrocotis"
# # Hepburn's Gray-crowned Rosy-Finch	Leucosticte tephrocotis littoralis
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Leucosticte tephrocotis littoralis"] <- "Leucosticte tephrocotis"
# # Gray-crowned Rosy-Finch (tephrocotis)	Leucosticte tephrocotis tephrocotis
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Leucosticte tephrocotis tephrocotis"] <- "Leucosticte tephrocotis"
# # Pribilof Islands Gray-crowned Rosy-Finch	Leucosticte tephrocotis umbrina
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Leucosticte tephrocotis umbrina"] <- "Leucosticte tephrocotis"

# # no subspecies in BBS but only co-occur interactions: Short-billed
# # Dowitcher	Limnodromus griseus hendersoni = Limnodromus griseus
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Limnodromus griseus hendersoni"] <- "Limnodromus griseus" 

# not in BBS: Cassia Crossbill	Loxia sinesciuris
# 
# # Wild Turkey - no subspecies in BBS but interactions mostly at main species
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Meleagris gallopavo intermedia"] <- "Meleagris gallopavo"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Meleagris gallopavo merriami"] <- "Meleagris gallopavo"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Meleagris gallopavo osceola"] <- "Meleagris gallopavo"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Meleagris gallopavo silvestris"] <- "Meleagris gallopavo"

# #California Towhee
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Melozone crissalis crissalis"] <- "Melozone crissalis"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Melozone crissalis petulans"] <- "Melozone crissalis"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Melozone crissalis senicula"] <- "Melozone crissalis"

## Canyon Towhee
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Melozone fusca fusca"] <- "Melozone fusca"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Melozone fusca mesoleuca"] <- "Melozone fusca"

# BBS no subspecies but interactions are only hybrids
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Melospiza georgiana georgiana"] <- "Melospiza georgiana"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Melospiza georgiana nigrescens"] <- "Melospiza georgiana"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Melospiza melodia gouldii"] <- "Melospiza melodia"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Melospiza melodia graminea"] <- "Melospiza melodia"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Melospiza melodia morphna"] <- "Melospiza melodia"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Melospiza melodia heermanni"] <- "Melospiza melodia"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Melospiza melodia montana"] <- "Melospiza melodia"
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Melospiza melodia cleonensis"] <- "Melospiza melodia"

# # BBS has no subspecies American Black-crowned Night-Heron Nycticorax nycticorax hoactli
# resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Nycticorax nycticorax hoactli"] <- "Nycticorax nycticorax"

# No subspecies in BBS: Passerella iliaca Fox Sparrows but all seem to have
# interactions doubled w main species (except hybrid)
 
# Brandt's Cormorant	Phalacrocorax penicillatus = Urile penicillatus
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Phalacrocorax penicillatus"] <- "Urile penicillatus"

# Ruby-crowned Kinglet Regulus calendula
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Regulus calendula"] <- "Corthylio calendula"

#Spotted Dove	Spilopelia chinensis		
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Spilopelia chinensis"] <- "Streptopelia chinensis"

resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Setophaga coronata auduboni"] <- "Setophaga coronata auduboni"

resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Ammospiza leconteii"] <- "Ammospiza leconteii"

resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Ammospiza maritima"] <- "Ammospiza maritima"

resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Anas diazi"] <- "Anas diazi"

resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Anser caerulescens"] <- "Anser caerulescens"

resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Anser rossii"] <- "Anser rossii"

resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Antigone canadensis"] <- "Antigone canadensis"

resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Aratinga nenday"] <- "Aratinga nenday"

resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Buteo plagiatus"] <- "Buteo plagiatus"

resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Calidris pugnax"] <- "Calidris pugnax"

# colima warbler Leiothlypis crissalis - not in BBS

# Northern Harrier	Circus cyaneus = Circus hudsonius
# Northern Harrier Circus cyaneus hudsonius = Circus hudsonius
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Circus cyaneus" & resolved.gbif$common_name.edit == "Northern Harrier" ] <- "Circus hudsonius"

resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Circus cyaneus hudsonius" & resolved.gbif$common_name.edit == "Northern Harrier" ] <- "Circus hudsonius"
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Circus hudsonius"] <- "Circus hudsonius"

# American Green-winged Teal Anas crecca carolinensis = change to BBS version just Anas crecca
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Anas crecca carolinensis"] <- "Anas crecca"

#Ross's Goose	Chen rossii
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Chen rossii"] <- "Anser rossii"

# Northern Shoveler	Anas clypeata = Spatula clypeata
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Anas clypeata"] <- "Spatula clypeata"
# Blue-winged Teal Anas discors = Spatula discors
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Anas discors"] <- "Spatula discors"
# White-winged Scoter	Melanitta fusca = Melanitta deglandi
resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Melanitta fusca"] <- "Melanitta deglandi"

resolved.gbif$scientific_name[resolved.gbif$scientific_name.edit == "Accipiter cooperii"] <- "Astur cooperii"

```





```
# previous binding code, can be deleted, kept for comparision

############################################################
# # Take the scientific_name in resolved.gbif and fixed.unresolved.gs and rbind them,
# # remove duplicates, then merge with CHECKLIST to get common name assigned. Keep
# # reference of the scientific_name.raw bc need to merge back into the int.raw data.
# int.final.names<-rbind(resolved.gbif,fixed.unresolved.gs)
# dim(int.final.names)
# # 5339; May 29, 2025: 5312 
# length(unique(int.final.names$scientific_name.raw))
# # 3913 OK May 29, 2025: 3889
# 
# # Remove duplicate rows, if any exist
# int.final.names <- int.final.names %>% 
#   distinct()
# dim(int.final.names)
# # 4576; May 29, 2025: 4551
# length(unique(int.final.names$scientific_name.raw))
# # 3913 OK; May 29, 2025: 3889 OK
# 


NOTE TO FIX THESE 4576 LATER; decide whether to assign Family level or Genus for
this instead of the scientific_name.raw. Some have some typos (only a few). Some
 of the int.final.names scientific_name are blank. Most are because they are
Genus sp. For now, leave these as is since we cannot get to species level on
these interactions.

```

```
# int.final.names.Gsp<-int.final.names[which(is.na(int.final.names$scientific_name)), ]
# dim(int.final.names.Gsp)
# 621 Genus-level entries ; May 29, 2025: 626
```

Previous code: handle Genus sp.


All the NA in scientific_name are "Genus sp.". If the NA exists in
scientific_name, assign it the scientific_name.edit which includes this
designation.

```
### 


# int.final.names$scientific_name1 <- ifelse(is.na(int.final.names$scientific_name), 
#                                         int.final.names$scientific_name.edit, 
#                                         int.final.names$scientific_name)
# names(int.final.names)[names(int.final.names) == "scientific_name"] <-"scientific_name.gbif.chklist"
# names(int.final.names)[names(int.final.names) == "scientific_name1"] <-"scientific_name"
```


```{r}
# # Now merge the GBIF & checked CHECKLIST-derived int.final.names$scientific_name
# # with the CHECKLIST to get final checklist common_name. First drop some
# # checklist columns.
# checklist.narrow<-subset(checklist, select=c("scientific_name",
#                                              "common_name",
#                                              "category",
#                                              "order",
#                                              "family"))
# checklist.narrow<-data.frame(checklist.narrow)
# int.checklist<-merge(int.final.names,checklist.narrow, by=c("scientific_name"),all.x=T)
# length(unique(int.checklist$scientific_name.raw))
# # 3913 OK; May 29, 2025: 3889 OK
# head(int.checklist)
# dim(int.checklist)
# # 4576; May 29, 2025: 4551
# 
# # 933 missing common names - about 30% are "Genus sp." but others are just
# # missing?? For now we are just going to focus on fixing the BBS species. Later
# # this needs to be edited with a better workflow. 
# int.checklist.NAcommon<-int.checklist[which(is.na(int.checklist$common_name)), ]
# dim(int.checklist.NAcommon)
# # 898; May 29, 2025: 894
# dim(int.checklist.NAcommon)-dim(int.final.names.Gsp)
# # 621 Genus-level entries from above but 277 (May 29: 268) missing common name! Some are
# # duplicate rows from scientific_name.raw. Also some of the GBIF species
# # assignments do not work (GBIF taxonomic backbone is not quite up to date for
# # these birds)
# 
```

  


#### Manual fixes 

These are to be reviewed and kept or removed 

Notes from previous code

```
Aegolius funereus funereus:  Tengmalm's Owl - not in CHECKLIST
Agelaioides badius badius and Agelaioides badius bolivianus: Grayish Baywing subspecies but no common_name in CHECKLIST
Agelaioides badius fringillarius: Pale Baywing subspecies? only species in CHECKLIST
Aimophila ruficeps eremoeca: Rufus-crowned sparrow; no common_name in CHECKLIST
Alcippe poioicephala phayrei is a subspecies but no common_name in CHECKLIST

 Acrocephalus scirpaceus baeticatus and Acrocephalus gracilirostris leptorhynchus without CHECKLIST common_name
```

```{r}
# match with checklist

edits_by_scientific_name <- list(
    c("Acanthis flammea","Acanthis flammea hornemanni"),
    c("Accipiter bicolor","Astur bicolor"),
    c("Accipiter cooperii","Astur cooperii"),
    c("Accipiter gentilis laingi","Astur atricapillus laingi"),
    c("Accipiter gentilis","Astur atricapillus"),
    c("Accipiter melanoleucus","Astur melanoleucus"),
    c("Accipiter sp.","Aerospiza/Tachyspiza/Accipiter/Astur sp."),
    c("Aechmophorus occidentalis ephemeralis","Aechmophorus occidentalis"),
    c("Aechmophorus occidentalis occidentalis","Aechmophorus occidentalis"),
    c("Agelaioides badius fringillarius","Agelaioides fringillarius"),
    c("Ammospiza caudacuta caudacuta","Ammospiza caudacuta caudacuta"),
    c("Ammospiza caudacuta diversa","Ammospiza caudacuta diversa"),
    c("Schoeniparus castaneceps","Schoeniparus castaneceps"),
    c("Schoeniparus cinereus","Schoeniparus cinereus"),
    c("Schoeniparus dubius","Schoeniparus dubius"),
)

for(edit in edits_by_scientific_name){
  scientific_name.raw <- edit[1]
  scientific_name.edit <- edit[2]
  # check if it's on the checklist
  
  edit_note <- "Update to match checklist"
  ## check if the edited name is already correct! 
  already_edited_name <- int.raw.names[int.raw.names$scientific_name.raw == scientific_name.raw,]$scientific_name.edit
  
  if(already_edited_name == scientific_name.edit )
  int.raw.names <- add_name_edits(int.raw.names,
                    scientific_name.raw,
                    edit.note,
                    scientific_name.edit)
}
```

#### Match to checklist based on common name. 

These could match multiple rows in names
table, but this won't update rows that already have the matching scientific name 
edit, so the note won't be over-written

```{r}

edits_by_common_name <- list(
    c("Acanthiza apicalis albiventris","Red-Tailed Thornbill"),
    c("Accipiter striatus venator","Sharp-Shinned Hawk (Puerto Rican)"),
    c("Aechmophorus clarkii clarkii","Clark's Grebe (clarkii)"),
    c("Aechmophorus clarkii transitionalis","Clark's Grebe (transitionalis)"),
    c("Aimophila ruficeps eremoeca","Rufous-Crowned Sparrow (Eremoeca)"),
    c("Aimophila ruficeps scottii","Rufous-Crowned Sparrow (Scottii)"),
    c("Ammospiza caudacuta caudacuta","Saltmarsh Sparrow (Caudacuta)"),
    c("Ammospiza caudacuta diversa","Saltmarsh Sparrow (Diversa)"),
    c("Schoeniparus castaneceps","Rufous-winged Fulvetta"),
    c("Schoeniparus cinereus","Yellow-Throated Fulvetta"),
    c("Schoeniparus dubius","Rusty-Capped Fulvetta"),
)

for(edit in edits_by_common_name){
  common_name.raw <- edit[1]
  scientific_name.edit <- edit[2]
  # check if it's on the checklist
  
  edit_note <- "Update to match checklist based on common name"
  
  int.raw.names <- add_name_edits_by_common_name(int.raw.names, 
                       common_name.raw,
                        edit_notes,
                        scientific_name.edit
  )
}
 
```

Subset to the checklist 

Analysis Paper: 

1 sp1 and sp2 on checklist (canada CONUS)
Data Paper Goal: 

1. Sp1 or sp2 needs to be on Checklist (canada conus checklist)
2. Final check:which rows are not (sp1 AND sp2 on Canada Conus checklist)?
    how many?
    which of these are NOT on full clements list
    how many? 
    review data
    check against all clements
    assume names are fixed via gbif/taxa db
    
    if descions are made add name edits to be added to the int.raw.names list above



```{r}
#| label: subset_check
# rcode for above, prints a data frame of non-checklist rows
```

review data frame to make decisions

```{r}
# make additional edits using int.raw.names <- add_name_edits(...)
# re-run the block subset_check

```






```{r}
# ... FINISH THIS LATER FOR OTHER non-BBS species

# For now, focus on BBS splist because need to get these data cleaned and
# aligned for merging with bbs.obs for network modeling. Return to the cleaning
# below after this is completed...

#******** BBS WORK **********# 
# Merge scientific_name in splist with scientific_name in int.checklist
# to check current common_name list and identify gaps and updates to
# scientific_name. This will update most of the BBS species, but not necessarily the ones
# outside of BBS. "scientific_name" = the names agreed upon by CHECKLIST and by
# the GBIF-screened species. common_name = the CHECKLIST common_name.
int.checklist <- subset(
  int.checklist,
  select = c("scientific_name", "common_name", "scientific_name.raw","scientific_name.edit")
)
dim(int.checklist)
# 4576; 29 May 2025: 4551
int.checklist <- int.checklist %>% 
  distinct()
dim(int.checklist)
# 3915 OK; May 29, 2025: 3891
length(unique(int.checklist$scientific_name.raw))
# 3913 OK; May 29, 2025: 3889

```

## Save data

```{r}
save.image(file.path(L1_RData_dir,"AvianInteractionData_L1_29May2025.RData"))
write_csv((file.path(L1_RData_dir,"avian_interaction_raw_to_checklist_names.csv")))
```


### Subspecies

check if there are any subspecies remaining that have interactions

for those, decide what to do with them if they exist, potentially publish in the 
database


```{r}
# PARKING LOT FOR CONTINUED CLEANING...

# Hoary Redpoll lumped into Redpoll, but not sure this is the case in the BBS...
# bbs.splist$scientific_name[bbs.splist$scientific_name.bbs2024 == "Acanthis
# flammea"] <- "Acanthis flammea hornemanni"

```
